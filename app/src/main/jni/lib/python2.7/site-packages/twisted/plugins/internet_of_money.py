"""
This twistd plugin enables to start Tribler headless using the twistd command.
"""
import os
import signal

from twisted.application.service import MultiService, IServiceMaker
from twisted.conch import manhole_tap
from twisted.internet import reactor
from twisted.internet import stdio
from twisted.internet.defer import Deferred, inlineCallbacks
from twisted.plugin import IPlugin
from twisted.protocols.basic import LineReceiver
from twisted.python import usage
from twisted.python.log import msg
from zope.interface import implements

from internetofmoney.RequiredField import RequiredField
from internetofmoney.RequiredInput import RequiredInput
from internetofmoney.session import Session
from internetofmoney.utils.exceptions import WrongPasswordException
from internetofmoney.utils.iban import IBANUtil


class IOMLineReceiver(LineReceiver):
    from os import linesep as delimiter

    def __init__(self, session):
        self.current_state = ''
        self.current_bank_selected = None
        self.current_input_deferred = None
        self.session = session

    def connectionMade(self):
        self.show_intro_state()

    def show_intro_state(self):
        self.current_state = 'intro'
        self.transport.write('Welcome to the Internet of Money CLI!\n')
        if self.session.is_locked:
            if os.path.exists(os.path.join(self.session.cache_dir, 'pwhash')):  # Wallet locked
                self.transport.write('Wallet locked - please enter your password:\n')
                self.transport.write('>>> ')
            else:  # First time opening the app
                self.transport.write('First time usage - please enter your password:\n')
                self.transport.write('>>> ')
        else:
            self.transport.write('Please select your bank (1-%d):\n' % len(self.session.managers))
            cur_ind = 1
            for manager in self.session.managers.itervalues():
                self.transport.write('%d) %s\n' % (cur_ind, manager.get_bank_name()))
                cur_ind += 1
            self.transport.write('%d) Quit application\n' % cur_ind)
            self.transport.write('>>> ')

    def on_registered(self, _):
        self.transport.write('%s registration successful!\n' % self.session.managers[self.current_bank_selected].get_bank_name())
        self.show_bank_main_menu(self.session.managers[self.current_bank_selected])

    def on_registration_error(self, failure):
        self.transport.write('Error when registering: %s\n' % failure)
        self.show_bank_main_menu(self.session.managers[self.current_bank_selected])

    def on_login(self, _):
        self.transport.write('%s login successful!\n' % self.session.managers[self.current_bank_selected].get_bank_name())
        self.show_bank_main_menu(self.session.managers[self.current_bank_selected])

    def on_login_error(self, failure):
        self.transport.write('Error when logging in: %s\n' % failure)
        self.show_bank_main_menu(self.session.managers[self.current_bank_selected])

    def on_balance(self, balance):
        self.transport.write('Available: %.2f (%s)\n' % (balance['available'], balance['currency']))
        self.transport.write('Pending: %.2f (%s)\n' % (balance['pending'], balance['currency']))
        self.show_bank_main_menu(self.session.managers[self.current_bank_selected])

    def on_balance_error(self, failure):
        self.transport.write('Error when getting balance: %s\n' % failure)
        self.show_bank_main_menu(self.session.managers[self.current_bank_selected])

    def on_transactions(self, transactions):
        for transaction in transactions:
            self.transport.write("from: %s, to: %s, id: %s, amount: %f\n" %
                                 (transaction['from'], transaction['to'], transaction['id'], transaction['amount']))
        self.show_bank_main_menu(self.session.managers[self.current_bank_selected])

    def on_transactions_error(self, failure):
        self.transport.write('Error when getting transactions: %s\n' % failure)
        self.show_bank_main_menu(self.session.managers[self.current_bank_selected])

    def on_payment(self, payment_id):
        cur_manager = self.session.managers[self.current_bank_selected]
        self.transport.write('%s payment successful (id: %s)!\n' % (cur_manager.get_bank_name(), str(payment_id)))
        self.show_bank_main_menu(self.session.managers[self.current_bank_selected])

    def on_payment_error(self, failure):
        self.transport.write('Error when performing payment: %s\n' % failure)
        self.show_bank_main_menu(self.session.managers[self.current_bank_selected])

    def on_fast_payment_success(self, payment_id):
        cur_manager = self.session.managers[self.current_bank_selected]
        self.transport.write('Fast %s payment successful (id: %s)!\n' %
                             (cur_manager.get_bank_name(), str(payment_id)))
        self.show_bank_main_menu(self.session.managers[self.current_bank_selected])

    def on_fast_payment_error(self, failure):
        self.transport.write('Error when performing fast payment: %s\n' % failure)
        self.show_bank_main_menu(self.session.managers[self.current_bank_selected])

    @inlineCallbacks
    def make_fast_payment(self, manager):
        if not self.money_community:
            self.transport.write('Switch functionality not enabled (run with --switch to enable it)\n')
            self.show_bank_main_menu(manager)
            return

        amount_field = RequiredField('amount', 'text', 'Please enter the amount of money to transfer')
        destination_field = RequiredField('destination_account', 'text', 'Please enter the destination IBAN account')
        required_input = RequiredInput('fast_payment_info', [amount_field, destination_field])
        payment_input = yield self.handle_required_input(required_input)

        source_iban = manager.get_address()
        destination_iban = payment_input['destination_account']
        amount = float(payment_input['amount'])
        eligable_candidate = yield self.money_community.has_eligable_router(IBANUtil.get_bank_id(source_iban),
                                                                            IBANUtil.get_bank_id(destination_iban),
                                                                            amount)
        if not eligable_candidate:
            self.transport.write('No eligable money switches found for fast transfer\n')
            self.show_bank_main_menu(manager)
            return

        switch_iban = self.money_community.candidate_services_map[eligable_candidate][IBANUtil.get_bank_id(source_iban)]
        self.money_community.send_money_using_router(eligable_candidate, manager, amount,
                                                     switch_iban, destination_iban)\
            .addCallback(self.on_fast_payment_success).addErrback(self.on_fast_payment_error)

    def lineReceived(self, line):
        # If we are waiting for user input, fire this Deferred first
        if self.current_input_deferred:
            self.current_input_deferred.callback(line)
            return

        if self.current_state == 'intro':
            if self.session.is_locked:
                password = line
                if os.path.exists(os.path.join(self.session.cache_dir, 'pwhash')):  # Wallet locked
                    try:
                        self.session.unlock(password)
                        self.transport.write('Wallet unlocked!\n')
                    except WrongPasswordException:
                        self.transport.write('Wrong password!\n')
                else:  # First time - set this password
                    self.session.set_password(password)
                    self.transport.write('Password set!\n')
                self.show_intro_state()
            else:
                num = int(line)
                if num == len(self.session.managers.values()) + 1:  # Quit Internet of Money
                    self.session.stop().addCallback(lambda _: reactor.stop())
                    return

                manager = self.session.managers.values()[num - 1]
                self.current_bank_selected = manager.get_bank_id()
                self.show_bank_main_menu(manager)
        else:
            num = int(line)
            manager = self.session.managers[self.current_bank_selected]
            if not manager.is_registered():
                if num == 1:  # Register
                    manager.register().addCallback(self.on_registered).addErrback(self.on_registration_error)
                elif num == 2:
                    self.show_intro_state()
            elif not manager.is_logged_in():
                if num == 1:  # Login
                    manager.login().addCallback(self.on_login).addErrback(self.on_login_error)
                elif num == 2:
                    self.show_intro_state()
            else:
                if num == 1:  # Get balance
                    manager.get_balance().addCallback(self.on_balance).addErrback(self.on_balance_error)
                elif num == 2:  # Get transactions
                    manager.get_transactions().addCallback(self.on_transactions).addErrback(self.on_transactions_error)
                elif num == 3:  # Make payment
                    manager.make_payment().addCallback(self.on_payment).addErrback(self.on_payment_error)
                elif num == 4:  # Make fast payment
                    self.make_fast_payment(manager)
                elif num == 5:  # Back
                    self.show_intro_state()

    def show_bank_main_menu(self, manager):
        self.current_state = '%s_main_menu' % manager.get_bank_name()
        self.transport.write('%s options:\n' % manager.get_bank_name())
        if not manager.is_registered():
            self.transport.write('1) register application\n')
            self.transport.write('2) back\n')
        elif manager.is_logged_in():
            self.transport.write('1) get balance\n')
            self.transport.write('2) get transaction history\n')
            self.transport.write('3) make payment\n')
            self.transport.write('4) make fast payment (experimental)\n')
            self.transport.write('5) back\n')
        else:
            self.transport.write('1) login\n')
            self.transport.write('2) back\n')

        self.transport.write('>>> ')

    def handle_required_input(self, required_input):
        """
        Return a Deferred that fires with the required input when available.

        :param required_input: Object representing the required input
        """
        user_input_deferred = Deferred()
        user_input_dict = {}

        def ask_for_user_input(required_field):
            self.current_input_deferred = Deferred()
            self.transport.write("%s:\n" % required_field.text)
            self.transport.write(">>> ")
            self.current_input_deferred.addCallback(lambda user_input: got_user_input(required_field.name, user_input))

        def got_user_input(field_name, input):
            user_input_dict[field_name] = input
            if required_input.is_last_name(field_name):
                # Done
                self.current_input_deferred = None
                user_input_deferred.callback(user_input_dict)
            else:
                field_index = required_input.get_index_of_field_name(field_name)
                next_field = required_input.required_fields[field_index + 1]
                ask_for_user_input(next_field)

        if required_input.error_text:
            self.transport.write('ERROR: %s\n' % required_input.error_text)
        ask_for_user_input(required_input.required_fields[0])

        return user_input_deferred


class Options(usage.Options):
    optParameters = [
        ["manhole", "m", 0, "Enable manhole telnet service listening at the specified port", int],
        ["port", "p", 8624, "Set the Dispersy listen port (defaults to 8624)", int],
        ["apiport", "a", 8085, "Set the RESTful API listen port (defaults to 8085)", int],
        ["cache", "c", "cache", "Set the cache directory", str],
        ["txfee", "f", 0.01, "Set the transaction fee for a switch (defaults to 0)", float],
    ]
    optFlags = [
        ["dummy", "d", "Enable some Dummy managers"],
        ["switch", "s", "Enable switching functionality"],
        ["input_cli", "g", "Enabled CLI input"]
    ]


class IOMServiceMaker(object):
    implements(IServiceMaker, IPlugin)
    tapname = "internet_of_money"
    description = "Internet-of-Money twistd plugin, starts as a service"
    options = Options

    def __init__(self):
        """
        Initialize the variables of the TriblerServiceMaker and the logger.
        """
        self.session = None
        self._stopping = False

    def start_iom(self, options):
        """
        Main method to startup the Internet-of-Money module.
        """
        def on_iom_shutdown(_):
            msg("Internet of Money shut down")
            reactor.stop()

        def signal_handler(sig, _):
            msg("Received shut down signal %s" % sig)
            if not self._stopping:
                self._stopping = True
                self.session.stop().addCallback(on_iom_shutdown)

        signal.signal(signal.SIGINT, signal_handler)
        signal.signal(signal.SIGTERM, signal_handler)

        msg("Starting Internet-of-Money")

        self.session = Session(options)
        self.session.start()

        if options["input_cli"]:
            # Initialize the line input handler
            line_receiver = IOMLineReceiver(self.session)
            stdio.StandardIO(line_receiver)

            for manager in self.session.managers.itervalues():
                manager.input_handler = line_receiver.handle_required_input

        msg("Internet-of-Money started")

    def makeService(self, options):
        """
        Construct the IOM service.
        """
        tribler_service = MultiService()
        tribler_service.setName("IOM")

        manhole_namespace = {}
        if options["manhole"] > 0:
            port = options["manhole"]
            manhole = manhole_tap.makeService({
                'namespace': manhole_namespace,
                'telnetPort': 'tcp:%d:interface=127.0.0.1' % port,
                'sshPort': None,
                'passwd': os.path.join(os.path.dirname(__file__), 'passwd'),
            })
            tribler_service.addService(manhole)

        reactor.callWhenRunning(self.start_iom, options)

        return tribler_service

service_maker = IOMServiceMaker()
