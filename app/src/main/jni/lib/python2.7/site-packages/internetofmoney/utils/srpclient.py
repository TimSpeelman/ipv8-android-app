from gmpy2 import mpz, powmod, t_mod, sub, mul, add
import random
import hashlib

from internetofmoney.utils.ingnumberpadder import INGNumberPadder


class SRPException(Exception):
    pass


class SRPClient(object):
    """
    This class contains the implementation for the SRP protocol, used for secure validation of a password.
    """

    def __init__(self):
        self.client_public_value = None
        self.server_public_value = None
        self.scrambler = None
        self.shared_secret = None
        self.private_value = None
        self.identity_hash = None
        self.multiplier = None
        self.salt = None
        self.raw_username = None
        self.raw_password = None
        self.session_key = None
        self.client_evidence_message = None
        self.server_evidence_message = None

        self.generator = 2
        modulus_number = mpz(
            'eeaf0ab9adb38dd69c33f80afa8fc5e86072618775ff3c0b9ea2314c9c256576d674df7496ea81d3383b4813d692c6e0e0d5d8'
            'e250b98be48e495c1d6089dad15dc7d7b46154d6b6ce8ef4ad69b15d4982559b297bcf1885c529f566660e57ec68edbc3c0572'
            '6cc02fd4cbf4976eaa9afd5138fe8376435b9fc61d2fc0eb06e3', base=16)
        self.modulus = modulus_number

    def get_modulus(self):
        return self.modulus

    def get_client_public_value(self):
        if self.client_public_value is None:
            self.calculate_client_public_value()
        return self.client_public_value

    def calculate_client_public_value(self):
        self.client_public_value = powmod(self.generator, self.get_private_value(), self.modulus)

    def get_server_public_value(self):
        if not self.server_public_value:
            raise SRPException("No server public value available!")

        return self.server_public_value

    def set_server_public_value_from_string(self, spv_str):
        self.set_server_public_value(mpz(spv_str, base=16))

    def set_server_public_value(self, spv):
        self.server_public_value = spv

    def get_scrambler(self):
        if self.scrambler is None:
            self.calculate_scrambler()
        return self.scrambler

    def calculate_scrambler(self):
        padded_cpv_data = INGNumberPadder.left_data_padding_to_length(
            SRPClient.mpz_to_ascii(self.get_client_public_value()), SRPClient.number_ascii_length(self.modulus))
        padded_svp_data = INGNumberPadder.left_data_padding_to_length(
            SRPClient.mpz_to_ascii(self.get_server_public_value()), SRPClient.number_ascii_length(self.modulus))

        self.scrambler = mpz(hashlib.sha1((padded_cpv_data + padded_svp_data).decode('hex')).hexdigest(), base=16)

    def get_shared_secret(self):
        if self.shared_secret is None:
            self.calculate_shared_secret()
        return self.shared_secret

    def calculate_shared_secret(self):
        val = powmod(self.generator, self.get_identity_hash(), self.modulus)
        val2 = mul(self.get_multiplier(), val)
        val3 = sub(self.get_server_public_value(), val2)
        val4 = mul(self.get_scrambler(), self.get_identity_hash())
        val5 = add(self.get_private_value(), val4)
        val6 = t_mod(val3, self.modulus)
        val7 = t_mod(val5, self.modulus)
        self.shared_secret = powmod(val6, val7, self.modulus)

    def get_private_value(self):
        if self.private_value is None:
            self.calculate_private_value()
        return self.private_value

    def calculate_private_value(self):
        self.private_value = SRPClient.random_number(64)

    def get_multiplier(self):
        if self.multiplier is None:
            self.calculate_multiplier()
        return self.multiplier

    # leading zero are removed by python, we add them manually
    def calculate_multiplier(self):
        padded_generator_data = "00" + INGNumberPadder.left_data_padding_to_length(
            SRPClient.mpz_to_ascii(self.generator), SRPClient.number_ascii_length(self.modulus))
        value = SRPClient.mpz_to_ascii(self.modulus) + padded_generator_data.decode('hex')
        sha1ed_value = hashlib.sha1(value).hexdigest()
        self.multiplier = mpz(sha1ed_value, base=16)

    def get_identity_hash(self):
        if self.identity_hash is None:
            self.calculate_identity_hash()
        return self.identity_hash

    def calculate_identity_hash(self):
        verify_string = self.raw_username + ":" + self.raw_password
        sha1ed_verify_string = hashlib.sha1(verify_string).hexdigest()
        salted_sha1ed_verify_string = SRPClient.mpz_to_hex(self.get_salt()) + sha1ed_verify_string
        sha1ed_salted_sha1ed_verify_string = hashlib.sha1(salted_sha1ed_verify_string.decode('hex')).hexdigest()
        self.identity_hash = mpz(sha1ed_salted_sha1ed_verify_string, base=16)

    def get_salt(self):
        return self.salt

    def set_salt(self, salt):
        self.salt = salt

    def set_salt_from_string(self, salt_str):
        self.salt = mpz(salt_str, base=16)

    def set_username(self, username):
        self.raw_username = username

    def get_username(self):
        return self.raw_username

    def get_raw_username(self):
        return self.raw_username

    def set_password(self, password):
        self.raw_password = password

    def set_password_pin(self, pin):
        padding = SRPClient.mpz_to_hex(SRPClient.random_number(32))
        self.set_password_for_pin_with_padding(pin, padding)
        return padding

    def set_password_for_pin_with_padding(self, pin, padding):
        padding_str = padding.decode('hex')
        password_data = []
        for i in range(0, 8):
            password_data.append(padding_str[i])
        for i in range(0, len(pin)):
            password_data.append(pin[i])
        for i in range(0, 8):
            password_data.append(padding_str[i + 8])

        self.raw_password = ''.join(password_data)

    def get_password(self):
        return self.raw_password.decode('hex')

    def get_raw_password(self):
        return self.raw_password

    def get_session_key(self):
        if self.session_key is None:
            self.calculate_session_key()
        return self.session_key

    def calculate_session_key(self):
        if SRPClient.number_ascii_length(self.get_shared_secret()) == 0:
            return SRPClient.sha1_interleave_digest(SRPClient.mpz_to_ascii(self.get_shared_secret()))
        else:
            index = 0
            shared_secret_ascii = SRPClient.mpz_to_ascii(self.get_shared_secret())
            while ord(shared_secret_ascii[index]) == 0 and index < len(shared_secret_ascii):
                index += 1
            if index != 0:
                spliced_shared_secret_ascii = shared_secret_ascii[index:]
                return SRPClient.sha1_interleave_digest(spliced_shared_secret_ascii)
            self.session_key = mpz(
                SRPClient.sha1_interleave_digest(SRPClient.mpz_to_ascii(self.get_shared_secret())).encode('hex'), base=16)

    def get_session_key_of_size(self, size):
        ascii_session_key = SRPClient.mpz_to_ascii(self.get_session_key())
        return ascii_session_key[:size]

    def get_client_evidence_message(self):
        if self.client_evidence_message is None:
            self.calculate_client_evidence_message()
        return self.client_evidence_message

    def calculate_client_evidence_message(self):
        sha1ed_modulus_data = hashlib.sha1(SRPClient.mpz_to_ascii(self.modulus)).hexdigest()
        sha1ed_generator_data = hashlib.sha1(SRPClient.mpz_to_ascii(self.generator)).hexdigest()

        xored_generator_data_with_modulus_data = SRPClient.xor_data(sha1ed_modulus_data, sha1ed_generator_data)
        scrambler_data = SRPClient.mpz_to_ascii(self.get_scrambler())

        padded_scrambler_data = INGNumberPadder.left_data_padding_to_length(scrambler_data, 0x14)
        sha1ed_padded_scrambler_data = hashlib.sha1(padded_scrambler_data.decode('hex')).hexdigest()

        cvp_data = SRPClient.mpz_to_ascii(self.get_client_public_value())
        padded_cvp_data = INGNumberPadder.left_data_padding_to_length(cvp_data, SRPClient.number_ascii_length(self.modulus))

        spv_data = SRPClient.mpz_to_ascii(self.get_server_public_value())
        padded_spv_data = INGNumberPadder.left_data_padding_to_length(spv_data, SRPClient.number_ascii_length(self.modulus))

        result_hex_string = xored_generator_data_with_modulus_data + sha1ed_padded_scrambler_data + SRPClient.mpz_to_hex(
            self.get_salt()) + padded_cvp_data + padded_spv_data + SRPClient.mpz_to_hex(self.get_session_key())
        self.client_evidence_message = mpz(hashlib.sha1(result_hex_string.decode('hex')).hexdigest(), base=16)

    def get_server_evidence_message(self):
        if self.server_evidence_message is None:
            self.calculate_server_evidence_message()
        return self.server_evidence_message

    def calculate_server_evidence_message(self):
        padded_client_public_value = INGNumberPadder.left_data_padding_to_length(
            SRPClient.mpz_to_ascii(self.get_client_public_value()), SRPClient.number_ascii_length(self.modulus))

        result_hex_string = padded_client_public_value + SRPClient.mpz_to_hex(self.get_client_evidence_message()) + \
                            SRPClient.mpz_to_hex(self.get_session_key())
        self.server_evidence_message = mpz(hashlib.sha1(result_hex_string.decode('hex')).hexdigest(), base=16)

    def validate_server_evidence_message(self, msg):
        mpz_msg = mpz(msg, base=16)
        return mpz_msg == self.get_server_evidence_message()

    def verifier(self):
        ihash = self.get_identity_hash()
        if ihash is not None:
            return powmod(self.generator, ihash, self.modulus)
        return 0

    def validate_public_value(self, pv):
        return t_mod(pv, self.modulus) == 0

    def verify(self):
        if self.identity_hash is not None:
            return powmod(self.generator, self.identity_hash, self.modulus) > 0
        else:
            return False

    @staticmethod
    def random_number(length):
        return mpz(''.join((random.choice('0123456789ABCDEF') for _ in range(length))), base=16)

    @staticmethod
    def sha1_interleave_digest(data):
        buf_even = [chr(0)] * (len(data) / 2)
        buf_odd = [chr(0)] * (len(data) / 2)

        for i in range(len(data)):
            if i % 2 == 0:
                if i / 2 >= len(buf_even):
                    continue
                buf_even[i / 2] = data[i]
            else:
                if i / 2 >= len(buf_odd):
                    continue
                buf_odd[i / 2] = data[i]

        sha1ed_buff_even = hashlib.sha1(''.join(buf_even)).hexdigest().decode("hex")
        sha1ed_buff_odd = hashlib.sha1(''.join(buf_odd)).hexdigest().decode("hex")

        final_buf = [0] * 40  # "Allocate" a str with length 40
        for i in range(0, 20):
            final_buf[i * 2] = sha1ed_buff_even[i]
            final_buf[i * 2 + 1] = sha1ed_buff_odd[i]

        return ''.join(''.join(str(v) for v in final_buf))

    @staticmethod
    def xor_data(data1, data2):
        data1 = data1.decode('hex')
        data2 = data2.decode('hex')
        xored_data = []
        for i in range(len(data1)):
            res = str(chr(ord(data1[i]) ^ ord(data2[i]))).encode('hex')
            if len(res) == 1:
                res = "0" + res
            xored_data.append(res)
        return ''.join(''.join(v for v in xored_data))

    @staticmethod
    def number_ascii_length(number):
        return len(SRPClient.mpz_to_hex(number)) / 2

    @staticmethod
    def mpz_to_hex(number):
        hex_str = format(number, 'x')
        if len(hex_str) % 2 == 1:
            hex_str = "0" + hex_str
        return hex_str

    @staticmethod
    def mpz_to_ascii(number):
        return SRPClient.mpz_to_hex(number).decode('hex')
