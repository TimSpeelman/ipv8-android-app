import base64
import hashlib
import hmac
import json

import zlib
from urllib import urlencode

from Crypto import Random
from Crypto.Cipher import PKCS1_v1_5
from Crypto.Hash import SHA
from twisted.internet.defer import fail, inlineCallbacks, returnValue
from twisted.python.failure import Failure
from twisted.web.client import PartialDownloadError

from internetofmoney.RequiredField import RequiredField
from internetofmoney.RequiredInput import RequiredInput
from internetofmoney.managers.ing.INGBaseManager import INGBaseManager
from internetofmoney.utils.exceptions import RegistrationError, LoginError, RequestError, PaymentError, \
    NotRegisteredException
from internetofmoney.utils.ingcrypto import INGCryptor
from internetofmoney.utils.ingkeypair import INGKeyPair
from internetofmoney.utils.ingnumberpadder import INGNumberPadder
from internetofmoney.utils.srpclient import SRPClient


class INGManager(INGBaseManager):

    def is_logged_in(self):
        return self.logged_in

    def persistent_storage_filename(self):
        return 'ing_account.json'

    def get_address(self):
        return self.persistent_storage['account_iban']

    @staticmethod
    def get_payment_info_fields():
        """
        Return the fields required for making a payment with ING.
        """
        amount_field = RequiredField('amount', 'text', 'Please enter the amount of money to transfer')
        destination_field = RequiredField('destination_account', 'text', 'Please enter the destination IBAN account')
        description_field = RequiredField('description', 'text', 'Please the payment description')
        return [amount_field, destination_field, description_field]

    @staticmethod
    def get_registration_fields():
        """
        Return the fields required for registering an ING device.
        """
        card_exp_field = RequiredField('card_expiration', 'text',
                                       'Please enter the expiration date of the card (i.e. 082018')
        card_code_field = RequiredField('card_code', 'text', 'Please enter your card number')
        account_number_field = RequiredField('account_number', 'text', 'Please enter your account number')
        dob_field = RequiredField('dob', 'text', 'Please enter your date of birth')
        return [card_exp_field, card_code_field, account_number_field, dob_field]

    def register(self):
        """
        Start the registration sequence of a device.
        """
        stage = self.persistent_storage['registration_stage']
        self.database.log_event('info', 'Starting registration sequence for %s, stage: %d'
                                % (self.get_bank_name(), stage))
        if stage == 0:
            return self.perform_device_registration_request()
        elif stage == 1:
            return self.perform_register_user_data_request()
        elif stage == 2:
            return self.ask_activation_code()
        elif stage == 3:
            return self.perform_accept_terms_request()
        elif stage == 4:
            return self.ask_new_pin()

    def perform_device_registration_request(self):
        """
        Create a new device registration. Start by sending the profile information to the server.
        """
        message = self.symmetric_key.get_symmetric_key().decode("hex")
        h = SHA.new(message)
        cipher = PKCS1_v1_5.new(self.server_public_key)
        ciphertext = cipher.encrypt(message + h.digest())
        enc_symmetric_key = ''.join(x.encode('hex') for x in ciphertext)

        public_key = '00' + format(INGKeyPair(self.cache_dir).public_key.n, 'x') + '|010001'

        data = {
            "previousProfileId": "",
            "deviceType": "iPhone4,1",
            "profileId": self.get_profile_id(),
            "encSymmetricKey": enc_symmetric_key,
            "deviceBrand": "Apple",
            "publicKey": public_key,
            "osVersion": "8.1.2",
            "deviceTag": "iPhone"
        }

        return self.perform_request('https://services.ing.nl/mb/registration/registerProfile',
                                    request_type='POST', raw_data=urlencode(data).replace('+', '%20'),
                                    headers=self.get_ing_headers()) \
            .addBoth(self.on_register_profile_response)

    def on_register_profile_response(self, response):
        if isinstance(response, Failure) and not isinstance(response.value, PartialDownloadError):
            return fail(response)

        json_response = json.loads(response.value.response)
        if not INGManager.check_result_code(json_response['securityProxyResponseEnvelope']):
            return fail(Failure(RegistrationError('Error when registering profile: %s' % json_response)))

        api_response = json_response['securityProxyResponseEnvelope']['apiResponse'][6:]
        self.persistent_storage['session'] = json_response['securityProxyResponseEnvelope']['session']
        self.save_storage()

        api_json_data = json.loads(zlib.decompress(base64.b64decode(api_response)))
        if not INGManager.check_return_code(api_json_data['registerProfileResponseEnvelope']):
            return fail(Failure(RegistrationError('Error when registering profile: %s' % api_json_data)))

        self.update_register_stage(1)
        session_key = api_json_data['registerProfileResponseEnvelope']['sessionKey']
        key = INGKeyPair(self.cache_dir).private_key

        sentinel = Random.new().read(15 + SHA.digest_size)  # The sentinel is not actively check, can be None
        decrypted_session_key = PKCS1_v1_5.new(key).decrypt(session_key.decode("hex"), sentinel)
        self.persistent_storage['session_key'] = decrypted_session_key.encode('hex')
        self.save_storage()

        return self.perform_register_user_data_request()

    def perform_register_user_data_request(self):
        required_input = RequiredInput('ing_register_info', INGManager.get_registration_fields())
        return self.input_handler(required_input).addCallback(self.on_register_user_data_input)

    def on_register_user_data_input(self, input):
        session_key = str(self.persistent_storage['session_key']).decode('hex')
        cryptor = INGCryptor(session_key)

        values = {
            'debitCardExpirationMonth': cryptor.encrypt(input['card_expiration']).encode("hex"),
            'debitCardCode': cryptor.encrypt(input['card_code']).encode("hex"),
            'accountNumber': cryptor.encrypt(input['account_number']).encode("hex"),
            'dateOfBirth': cryptor.encrypt(input['dob']).encode("hex"),
            'session': str(self.persistent_storage['session'])
        }

        return self.perform_request('https://services.ing.nl/mb/registration/proveIdentity',
                                    request_type='POST', raw_data=urlencode(values), headers=self.get_ing_headers()) \
            .addBoth(self.on_register_user_data_response)

    def on_register_user_data_response(self, response):
        if isinstance(response, Failure) and not isinstance(response.value, PartialDownloadError):
            return fail(response)

        self.update_register_stage(2)

        json_response = json.loads(response.value.response)
        if not INGManager.check_result_code(json_response['securityProxyResponseEnvelope']):
            return fail(Failure(RegistrationError('Error when proving identity during register: %s' % json_response)))

        api_json_data = self.decrypt_api_response(response)
        if not INGManager.check_return_code(api_json_data['proveIdentityResponseEnvelope']):
            return fail(Failure(RegistrationError('Error when proving identity during register: %s' % api_json_data)))

        return self.ask_activation_code()

    def ask_activation_code(self):
        code_field = RequiredField('activation_code', 'text', 'Please enter the activation code given by the website')
        required_input = RequiredInput('ing_activation_code', [code_field])
        return self.input_handler(required_input).addCallback(self.perform_get_variables_request)

    def perform_get_variables_request(self, input):
        request_url = 'https://services.ing.nl/mb/authentication/getVariables?profileId=%s' % str(self.get_profile_id())
        return self.perform_request(request_url, headers=self.get_ing_headers())\
            .addBoth(lambda response: self.on_get_variables_response(response, input, is_login=False))

    def on_get_variables_response(self, response, input, is_login):
        if isinstance(response, Failure) and not isinstance(response.value, PartialDownloadError):
            return fail(response)

        json_response = json.loads(response.value.response)
        if not INGManager.check_result_code(json_response['securityProxyResponseEnvelope']):
            return fail(Failure(RegistrationError('Error when fetching variables: %s' % json_response)))

        self.persistent_storage['session_string'] = json_response["securityProxyResponseEnvelope"]["session"]
        self.save_storage()

        api_response = json_response["securityProxyResponseEnvelope"]["apiResponse"][6:]
        api_json_data = json.loads(zlib.decompress(base64.b64decode(api_response)))
        if not INGManager.check_return_code(api_json_data['getVariablesResponseEnvelope']):
            return fail(Failure(RegistrationError('Error when fetching variables: %s' % api_json_data)))

        srp_salt = api_json_data["getVariablesResponseEnvelope"]["srpSalt"]
        srp_server_key = api_json_data["getVariablesResponseEnvelope"]["serverSrpKey"]
        self.persistent_storage['srp_salt'] = srp_salt  # Save the SRP salt as hex string
        self.save_storage()

        # Set all required SRP values
        if is_login:
            # Reset the SRP client
            self.srp_client = SRPClient()
            self.srp_client.set_username(str(self.get_profile_id()))
            self.srp_client.set_password_for_pin_with_padding(str(self.persistent_storage['pin']),
                                                              self.persistent_storage['pin_padding'].encode('utf-8'))
        else:
            self.srp_client.set_password(input['activation_code'])

        self.srp_client.set_server_public_value_from_string(srp_server_key)
        self.srp_client.set_salt_from_string(srp_salt)

        client_evidence_message = SRPClient.mpz_to_hex(self.srp_client.get_client_evidence_message())
        cpv_data = SRPClient.mpz_to_ascii(self.srp_client.get_client_public_value())
        padded_cvp_data = INGNumberPadder.left_data_padding_to_length(cpv_data, SRPClient.number_ascii_length(
            self.srp_client.get_modulus()))

        request_data = {
            'clientEvidenceMessage': client_evidence_message,
            'clientPublicValue': padded_cvp_data,
            'session': self.persistent_storage['session_string']
        }

        if is_login:
            return self.perform_request('https://services.ing.nl/mb/authentication/checkPin',
                                        request_type='POST', raw_data=urlencode(request_data),
                                        headers=self.get_ing_headers()).addBoth(self.on_check_pin_response)
        else:
            return self.perform_request('https://services.ing.nl/mb/authentication/checkActivationCode',
                                        request_type='POST', raw_data=urlencode(request_data),
                                        headers=self.get_ing_headers()).addBoth(self.on_check_activation_code_response)

    def on_check_activation_code_response(self, response):
        if isinstance(response, Failure) and not isinstance(response.value, PartialDownloadError):
            return fail(response)

        self.srp_client.set_username(str(self.get_profile_id()))

        json_response = json.loads(response.value.response)
        if not INGManager.check_result_code(json_response['securityProxyResponseEnvelope']):
            return fail(Failure(RegistrationError('Error when entering activation code: %s' % json_response)))

        api_response = json_response["securityProxyResponseEnvelope"]["apiResponse"][6:]
        api_json_data = json.loads(zlib.decompress(base64.b64decode(api_response)))
        if not INGManager.check_return_code(api_json_data['checkActivationCodeResponseEnvelope']):
            return fail(Failure(RegistrationError('Error when entering activation code: %s' % api_json_data)))

        srp_server_evidence_message = api_json_data['checkActivationCodeResponseEnvelope']['evidenceMessage']
        if not self.srp_client.validate_server_evidence_message(srp_server_evidence_message):
            return fail(Failure(RegistrationError('Error when validation activation code evidence message')))

        new_session_key = self.srp_client.get_session_key_of_size(INGCryptor.KEY_SIZE)  # ascii key
        self.persistent_storage['session_key'] = new_session_key.encode('hex')
        self.update_register_stage(3)
        return self.perform_accept_terms_request()

    def perform_accept_terms_request(self):
        session_key = str(self.persistent_storage['session_key'].decode('hex'))
        cryptor = INGCryptor(session_key)
        terms_hash = cryptor.encrypt(
            "66326564373261636135616133303066656132313037666339373538646163306562653561646130".decode('hex'))\
            .encode('hex')
        terms_version = cryptor.encrypt("9.0").encode('hex')
        request_data = {
            'termsHash': terms_hash,
            'termsVersion': terms_version,
            'session': str(self.persistent_storage['session_string'])
        }

        return self.perform_request('https://services.ing.nl/mb/authentication/acceptTerms',
                                    request_type='POST', raw_data=urlencode(request_data),
                                    headers=self.get_ing_headers()).addBoth(self.on_accept_terms_response)

    def on_accept_terms_response(self, response):
        if isinstance(response, Failure) and not isinstance(response.value, PartialDownloadError):
            return fail(response)

        json_response = json.loads(response.value.response)
        if not INGManager.check_result_code(json_response['securityProxyResponseEnvelope']):
            return fail(Failure(RegistrationError('Error when accepting terms and agreements: %s' % json_response)))

        api_json_data = self.decrypt_api_response(response)
        if not INGManager.check_return_code(api_json_data['acceptTermsResponseEnvelope']):
            return fail(Failure(RegistrationError('Error when accepting terms and agreements: %s' % api_json_data)))

        self.update_register_stage(4)
        return self.ask_new_pin()

    def ask_new_pin(self):
        pin_field = RequiredField('new_pin', 'text', 'Please enter a new pin code used to login')
        required_input = RequiredInput('new_pin', [pin_field])
        return self.input_handler(required_input).addCallback(self.perform_register_pin_request)

    def perform_register_pin_request(self, input):
        pin_client = SRPClient()
        pin_client.set_salt_from_string(str(self.persistent_storage['srp_salt']))
        pin_client.set_username(str(self.get_profile_id()))
        padding = pin_client.set_password_pin(input['new_pin'].encode('utf-8'))
        self.persistent_storage['pin_padding'] = padding
        self.save_storage()
        verifier = SRPClient.mpz_to_hex(pin_client.verifier())

        session_key = str(self.persistent_storage['session_key'].decode('hex'))
        cryptor = INGCryptor(session_key)
        verifier_encrypted_data = cryptor.encrypt(verifier).encode('hex')
        request_data = {
            'pin': verifier_encrypted_data,
            'session': str(self.persistent_storage['session_string'])
        }

        return self.perform_request('https://services.ing.nl/mb/authentication/registerPin',
                                    request_type='POST', raw_data=urlencode(request_data),
                                    headers=self.get_ing_headers()).addBoth(
            lambda response: self.on_register_pin_response(response, input))

    def on_register_pin_response(self, response, input):
        if isinstance(response, Failure) and not isinstance(response.value, PartialDownloadError):
            return fail(response)

        json_response = json.loads(response.value.response)
        if not INGManager.check_result_code(json_response['securityProxyResponseEnvelope']):
            return fail(Failure(RegistrationError('Error when registering new pin code: %s' % json_response)))

        api_json_data = self.decrypt_api_response(response)
        if not INGManager.check_return_code(api_json_data['pinRegistrationResponseEnvelope']):
            return fail(Failure(RegistrationError('Error when registering new pin code: %s' % api_json_data)))

        self.persistent_storage['pin'] = input['new_pin']
        self.save_storage()

        def on_got_accounts(accounts):
            self.persistent_storage['account_iban'] = accounts['iban']
            self.persistent_storage['registered'] = True
            self.save_storage()

        return self.login().addCallback(lambda _: self.get_accounts()).addCallback(on_got_accounts)

    def login(self):
        """
        Login to your ING account.
        """
        if not self.is_registered():
            return fail(Failure(NotRegisteredException()))

        self.database.log_event('info', 'Starting login sequence for %s' % self.get_bank_name())
        request_url = 'https://services.ing.nl/mb/authentication/getVariables?profileId=%s' % str(self.get_profile_id())
        return self.perform_request(request_url, headers=self.get_ing_headers())\
            .addBoth(lambda response: self.on_get_variables_response(response, None, is_login=True))

    def on_check_pin_response(self, response):
        if isinstance(response, Failure) and not isinstance(response.value, PartialDownloadError):
            return fail(response)

        self.srp_client.set_username(str(self.get_profile_id()))

        json_response = json.loads(response.value.response)
        if not INGManager.check_result_code(json_response['securityProxyResponseEnvelope']):
            return fail(Failure(LoginError('Error when checking pin code: %s' % json_response)))

        api_response = json_response["securityProxyResponseEnvelope"]["apiResponse"][6:]
        api_json_data = json.loads(zlib.decompress(base64.b64decode(api_response)))
        if not INGManager.check_return_code(api_json_data['checkPinResponseEnvelope']):
            return fail(Failure(LoginError('Error when entering pin code: %s' % api_json_data)))

        srp_server_evidence_message = api_json_data['checkPinResponseEnvelope']['evidenceMessage']
        if not self.srp_client.validate_server_evidence_message(srp_server_evidence_message):
            return fail(Failure(LoginError('Pin code not ok!')))

        new_session_key = self.srp_client.get_session_key_of_size(INGCryptor.KEY_SIZE)  # ascii key
        self.persistent_storage['session_key'] = new_session_key.encode('hex')
        return self.perform_get_session_key_request()

    def perform_get_session_key_request(self):
        session_string = str(self.persistent_storage['session_string'])
        return self.perform_request('https://services.ing.nl/mb/authentication/getSessionKey?session=%s' %
                                    session_string,
                                    headers=self.get_ing_headers()).addBoth(self.on_get_session_key_response)

    def on_get_session_key_response(self, response):
        if isinstance(response, Failure) and not isinstance(response.value, PartialDownloadError):
            return fail(response)

        json_response = json.loads(response.value.response)
        if not INGManager.check_result_code(json_response['securityProxyResponseEnvelope']):
            return fail(Failure(LoginError('Error when fetching session key: %s' % json_response)))

        self.persistent_storage['session_string'] = json_response["securityProxyResponseEnvelope"]["session"]
        self.save_storage()

        api_json_data = self.decrypt_api_response(response)
        if not INGManager.check_return_code(api_json_data['getSessionKeyResponseEnvelope']):
            return fail(Failure(LoginError('Error when entering pin code: %s' % api_json_data)))

        new_session_key = api_json_data['getSessionKeyResponseEnvelope']['sessionKey'].decode('hex')
        decrypted_session_key = INGKeyPair(self.cache_dir).decrypt(new_session_key)
        self.persistent_storage['session_key'] = decrypted_session_key.encode('hex')
        self.save_storage()

        return self.perform_get_subscriptions_request()

    def perform_get_subscriptions_request(self):
        session_string = str(self.persistent_storage['session_string'])
        return self.perform_request('https://services.ing.nl/mb/authentication/getSubscriptions?session=%s' %
                                    session_string,
                                    headers=self.get_ing_headers()).addBoth(self.on_get_subscriptions_response)

    def on_get_subscriptions_response(self, response):
        if isinstance(response, Failure) and not isinstance(response.value, PartialDownloadError):
            return fail(response)

        json_response = json.loads(response.value.response)
        if not INGManager.check_result_code(json_response['securityProxyResponseEnvelope']):
            return fail(Failure(RequestError('Error when fetching subscriptions: %s' % json_response)))

        api_json_data = self.decrypt_api_response(response)
        if not INGManager.check_return_code(api_json_data['getSubscriptionsResponseEnvelope']):
            return fail(Failure(RequestError('Error when fetching subscriptions: %s' % api_json_data)))

        agreement_id = api_json_data['getSubscriptionsResponseEnvelope']['subscriptions'][0]['agreementId']
        agreement_type = api_json_data['getSubscriptionsResponseEnvelope']['subscriptions'][0]['agreementType']
        self.persistent_storage['agreement_id'] = agreement_id
        self.persistent_storage['agreement_type'] = agreement_type

        self.save_storage()
        self.logged_in = True

    #
    # Get balance
    #

    def get_balance(self):
        self.database.log_event('info', 'Fetching balance for %s, account %s' %
                                (self.get_bank_name(), self.get_address()))

        def on_accounts_response(accounts):
            return {
                'available': float(accounts['balance']) / 100.0,
                'pending': 0.0,
                'currency': accounts['currency']
            }

        return self.check_login().addCallback(lambda _: self.get_accounts()).addCallback(on_accounts_response)

    #
    # Get accounts
    #

    def get_accounts(self):
        session_string = str(self.persistent_storage['session_string'])
        return self.perform_request('https://services.ing.nl/mb/aggregation/getAccounts?session=%s' % session_string,
                                    headers=self.get_ing_headers()).addBoth(self.on_get_accounts_response)

    def on_get_accounts_response(self, response):
        if isinstance(response, Failure) and not isinstance(response.value, PartialDownloadError):
            return fail(response)

        json_response = json.loads(response.value.response)
        if not INGManager.check_result_code(json_response['securityProxyResponseEnvelope']):
            return fail(Failure(RequestError('Error when fetching balance: %s' % json_response)))

        api_json_data = self.decrypt_api_response(response)
        if not INGManager.check_return_code(api_json_data['getAccountsResponseEnvelope']):
            return fail(Failure(RequestError('Error when fetching balance: %s' % api_json_data)))

        iban = str(api_json_data['getAccountsResponseEnvelope']['accounts'][0]['iban'])
        account_number = str(api_json_data['getAccountsResponseEnvelope']['accounts'][0]['accountNumber'])
        holder_name = str(api_json_data['getAccountsResponseEnvelope']['accounts'][0]['accountName'])
        currency = str(api_json_data['getAccountsResponseEnvelope']['accounts'][0]['accountCurrency'])
        balance = str(api_json_data['getAccountsResponseEnvelope']['accounts'][0]['accountBalanceInCents'])

        return {
            'iban': iban,
            'account_number': account_number,
            'holder_name': holder_name,
            'currency': currency,
            'balance': balance
        }

    #
    # Get transactions
    #

    def parse_transaction(self, transaction):
        is_outgoing = transaction['amountInCents'] < 0
        if is_outgoing:
            from_account = self.get_address()
            to_account = transaction['counterAccountNumber']
        else:
            from_account = transaction['counterAccountNumber']
            to_account = self.get_address()

        transaction_dict = {
            'id': '',
            'outgoing': is_outgoing,
            'from': str(from_account),
            'to': str(to_account),
            'amount': transaction["amount"],
            'fee_amount': 0.0,
            'currency': str(transaction["currency"]),
            'timestamp': str(transaction["transactionDate"]),
        }
        description = ""

        # Get description
        for specification_line in transaction["specificationLines"]:
            parts = specification_line.split(":")
            if len(parts) != 2:
                description += parts[0]
                continue
            if parts[0] == "Omschrijving":
                description += parts[1]
                continue
            transaction[parts[0]] = parts[1]
            transaction_dict["description"] = description
        return transaction_dict

    def parse_transactions(self, transactions):
        transactions_info = []
        for transaction in transactions:
            transactions_info.append(self.parse_transaction(transaction))
        return transactions_info

    def get_transactions(self):
        """
        Fetch the most recent transactions of an ING account.
        :return: A deferred that fires with a list containing transactions.
        """
        self.database.log_event('info', 'Fetching %s transactions of account %s' %
                                (self.get_bank_name(), self.get_address()))

        def perform_transactions_request(_):
            session_string = str(self.persistent_storage['session_string'])
            session_key = str(self.persistent_storage['session_key']).decode('hex')
            cryptor = INGCryptor(session_key)

            enc_date = cryptor.encrypt("").encode('hex')
            enc_account_number = cryptor.encrypt(str(self.get_address()[9:])).encode('hex')
            enc_agreement_type = cryptor.encrypt(str(self.persistent_storage['agreement_type'])).encode('hex')
            enc_agreement_id = cryptor.encrypt(str(self.persistent_storage['agreement_id'])).encode('hex')

            return self.perform_request(
                'https://services.ing.nl/mb/payments/getTransactions?startDate=' + enc_date + '&endDate=' + enc_date +
                '&accountNumber=' + enc_account_number + '&agreementType=' + enc_agreement_type + '&agreementId=' +
                enc_agreement_id + '&session=' + session_string,
                headers=self.get_ing_headers()).addBoth(self.on_get_transactions_response)
        return self.check_login().addCallback(perform_transactions_request)

    def on_get_transactions_response(self, response):
        if isinstance(response, Failure) and not isinstance(response.value, PartialDownloadError):
            return fail(response)

        json_response = json.loads(response.value.response)
        if not INGManager.check_result_code(json_response['securityProxyResponseEnvelope']):
            return fail(Failure(RequestError('Error when fetching transactions: %s' % json_response)))

        api_json_data = self.decrypt_api_response(response)
        if not INGManager.check_return_code(api_json_data['getTransactionsResponseEnvelope']):
            return fail(Failure(RequestError('Error when fetching transactions: %s' % api_json_data)))

        decrypted_json_data = self.decrypt_api_response(response)
        return self.parse_transactions(decrypted_json_data['getTransactionsResponseEnvelope']['transactions'])

    #
    #  Payments
    #

    def make_payment(self):
        """
        Initiate a new payment by asking the user for payment details.
        """
        required_input = RequiredInput('ing_payment_info', INGManager.get_payment_info_fields())
        return self.input_handler(required_input).addCallback(self.on_entered_payment_details)

    def on_entered_payment_details(self, input):
        return self.perform_payment(input['amount'], input['destination_account'], input['description'])

    def perform_payment(self, amount, destination_account, description):
        """
        Perform a payment.
        :param amount: the amount of money to transfer, in euro (i.e. 3.14).
        :param destination_account: the destination of the payment.
        :param description: an optional description that is appended to the payment.
        :return: A deferred that fires with a transaction id when the payment has been successful.
        """
        self.database.log_event('info', 'Starting %s payment with amount %f to %s (description: %s)' %
                                (self.get_bank_name(), float(amount), destination_account, description))

        self.payment_srp_client = SRPClient()
        self.payment_srp_client.set_username(str(self.get_profile_id()))
        self.payment_srp_client.set_password_for_pin_with_padding(str(self.persistent_storage['pin']),
                                                          self.persistent_storage['pin_padding'].encode('utf-8'))

        return self.get_accounts().addCallback(
            lambda account_info: self.perform_payment_request(amount, destination_account, description, account_info))

    def perform_payment_request(self, amount, destination_account, description, account_info):
        session_key = str(self.persistent_storage['session_key']).decode('hex')
        cryptor = INGCryptor(session_key)

        # prepare all payment fields
        nina_is_deposit = cryptor.encrypt("false").encode('hex')
        amount_in_cents = cryptor.encrypt(str(int(float(amount) * 100))).encode('hex')
        preferred_authorization_method = cryptor.encrypt("MPIN").encode('hex')
        set_address_book_item = cryptor.encrypt("false").encode('hex')
        end_to_end_id = cryptor.encrypt("").encode('hex')
        account_to_iban = cryptor.encrypt(str(destination_account)).encode('hex')
        account_to_number = cryptor.encrypt("").encode('hex')
        account_to_name = cryptor.encrypt("receiver").encode('hex')
        account_from_name = cryptor.encrypt(account_info["holder_name"]).encode('hex')
        account_from_iban = cryptor.encrypt(account_info["iban"]).encode('hex')
        agreement_type = cryptor.encrypt(str(self.persistent_storage['agreement_type'])).encode('hex')
        agreement_id = cryptor.encrypt(str(self.persistent_storage['agreement_id'])).encode('hex')
        description_line = cryptor.encrypt(str(description)).encode('hex')

        data = {"ninaIsDeposit": nina_is_deposit, "preferedAuthorizationMethod": preferred_authorization_method,
                "amountInCents": amount_in_cents, "setAddressBookItem": set_address_book_item,
                "endToEndId": end_to_end_id, "descriptionLine": description_line, "accountToIban": account_to_iban,
                "accountToNumber": account_to_number, "accountToName": account_to_name,
                "accountFromName": account_from_name, "agreementType": agreement_type,
                "accountFromIban": account_from_iban, "agreementId": agreement_id,
                "session": str(self.persistent_storage['session_string'])}

        return self.perform_request('https://services.ing.nl/mb/payments/submitSepaPayment',
                                    request_type='POST', raw_data=urlencode(data), headers=self.get_ing_headers())\
            .addBoth(
            lambda response: self.on_submit_sepa_payment_response(
                amount, str(destination_account), str(description), response))

    def on_submit_sepa_payment_response(self, amount, destination_iban, description, response):
        if isinstance(response, Failure) and not isinstance(response.value, PartialDownloadError):
            return fail(response)

        json_response = json.loads(response.value.response)
        if not INGManager.check_result_code(json_response['securityProxyResponseEnvelope']):
            return fail(Failure(PaymentError('Error when submitting sepa response: %s' % json_response)))

        api_json_data = self.decrypt_api_response(response)
        if not INGManager.check_return_code(api_json_data['submitSepaPaymentResponseEnvelope']):
            return fail(Failure(PaymentError('Error when submitting sepa response: %s' % api_json_data)))

        self.payment_srp_client.set_server_public_value_from_string(
            api_json_data['submitSepaPaymentResponseEnvelope']['authorizationParameters']
            ['parameters']['ServerPublicValue'])
        self.payment_srp_client.set_salt_from_string(
            api_json_data['submitSepaPaymentResponseEnvelope']['authorizationParameters']
            ['parameters']['Salt'])

        srp_session_key = SRPClient.mpz_to_ascii(self.payment_srp_client.get_session_key())
        verify_string = "PAYMENT|" + str(self.get_address()) + "|" + str(destination_iban) + \
                        "|1||" + str(description) + "||"

        client_evidence_message = SRPClient.mpz_to_hex(self.payment_srp_client.get_client_evidence_message())
        cpv_data = SRPClient.mpz_to_ascii(self.payment_srp_client.get_client_public_value())
        padded_cvp_data = INGNumberPadder.left_data_padding_to_length(
            cpv_data, SRPClient.number_ascii_length(self.payment_srp_client.get_modulus()))

        # create MAC
        mac = hmac.new(srp_session_key, verify_string, hashlib.sha1).hexdigest()

        session_key = str(self.persistent_storage['session_key']).decode('hex')
        cryptor = INGCryptor(session_key)

        enc_agreement_type = cryptor.encrypt(str(self.persistent_storage['agreement_type'])).encode('hex')
        enc_agreement_id = cryptor.encrypt(str(self.persistent_storage['agreement_id'])).encode('hex')
        enc_client_evidence_message = cryptor.encrypt(client_evidence_message).encode('hex')
        enc_cpv_data = cryptor.encrypt(padded_cvp_data).encode('hex')
        mac = cryptor.encrypt(mac).encode('hex')

        data = {"agreementType": enc_agreement_type, 'agreementId': enc_agreement_id,
                'authzClientPublicValue': enc_cpv_data, 'authzClientEvidenceMessage': enc_client_evidence_message,
                'authzMAC': mac, 'session': str(self.persistent_storage['session_string'])}

        return self.perform_request('https://services.ing.nl/mb/payments/authorizeSepaPayment',
                                    request_type='POST', raw_data=urlencode(data), headers=self.get_ing_headers())\
            .addBoth(lambda resp: self.on_authorize_payment_response(amount, destination_iban, description, resp))

    def on_authorize_payment_response(self, amount, destination_iban, description, response):
        if isinstance(response, Failure) and not isinstance(response.value, PartialDownloadError):
            return fail(response)

        self.payment_srp_client = None

        json_response = json.loads(response.value.response)
        if not INGManager.check_result_code(json_response['securityProxyResponseEnvelope']):
            return fail(Failure(PaymentError('Error when submitting payment auth: %s' % json_response)))

        api_json_data = self.decrypt_api_response(response)
        if not INGManager.check_return_code(api_json_data['authorizeSepaPaymentResponseEnvelope']):
            return fail(Failure(PaymentError('Error when submitting payment auth: %s' % api_json_data)))

        self.database.add_transaction('', unicode(self.get_address()), unicode(destination_iban),
                                      unicode(amount), unicode(description))

        # The ING does not return any useful identifier for this payment
        return ''
