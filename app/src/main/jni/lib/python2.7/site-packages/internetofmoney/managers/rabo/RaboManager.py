import os
import time
import xml.etree.ElementTree as ET
from base64 import b64encode

from twisted.internet.defer import succeed, fail
from twisted.python.failure import Failure

from internetofmoney.managers.rabo.RaboBaseManager import RaboBaseManager
from internetofmoney.RequiredField import RequiredField
from internetofmoney.RequiredInput import RequiredInput
from internetofmoney.utils.exceptions import NotRegisteredException


class RaboManager(RaboBaseManager):

    def is_logged_in(self):
        return self.logged_in

    def persistent_storage_filename(self):
        return 'rabo_account.json'

    def get_address(self):
        return self.persistent_storage['account_iban']

    @staticmethod
    def get_payment_info_fields():
        """
        Return the fields required for making a payment with Rabobank.
        """
        amount_field = RequiredField('amount', 'text', 'Please enter the amount of money to transfer')
        destination_field = RequiredField('destination_account', 'text', 'Please enter the destination IBAN account')
        description_field = RequiredField('description', 'text', 'Please the payment description')
        return [amount_field, destination_field, description_field]

    #
    # Registration
    #

    def register(self):
        """
        Register an existing bank account to use the mobile services.
        :return: A deferred that fires when the account has been registered.
        """
        self.database.log_event('info', 'Starting registration sequence for %s' % self.get_bank_name())
        request_data = '<?xml version="1.0" encoding="UTF-8" ?><LogonInfo xmlns="https://bankservices.rabobank.nl' \
                       '/auth/logoninfo/v1/request"><RequestedService>https://bankservices.rabobank.nl/services/' \
                       'balanceview/v1</RequestedService><EntranceCode>%s</EntranceCode></LogonInfo>' \
                       % time.strftime('%Y%m%d%H%M', time.gmtime())
        return self.perform_request('https://bankservices.rabobank.nl/auth/logoninfo/v1',
                                    request_type='POST', raw_data=request_data, headers=self.get_rabo_headers())\
            .addCallback(self.on_register_logon_info)

    def on_register_logon_info(self, response):
        tree = ET.ElementTree(ET.fromstring(response))
        self.logon_token = tree.find('.//{https://bankservices.rabobank.nl/auth/logoninfo/v1/response}LogonToken').text

        account_field = RequiredField('account', 'text', 'Please enter your Rabobank account number')
        card_field = RequiredField('card', 'text', 'Please enter your card number')

        required_input = RequiredInput('rabo_account_info', [account_field, card_field])
        return self.input_handler(required_input).addCallback(self.on_entered_registration_details)

    def on_entered_registration_details(self, input):
        self.persistent_storage['card_number'] = input['card']
        self.persistent_storage['account_number'] = input['account']
        self.save_storage()

        # Get the challenge
        request_data = '<?xml version="1.0" encoding="UTF-8" ?><InitiateLogonDebitCard ' \
                       'xmlns="https://bankservices.rabobank.nl/auth/initiatelogondebitcard/v1/request">' \
                       '<BankCardNumber>%s</BankCardNumber><LogonToken>%s</LogonToken>' \
                       '<ReaderType>RABO_SCANNER</ReaderType><BankAccountNumber>%s</BankAccountNumber>' \
                       '</InitiateLogonDebitCard>' % (input['card'], self.logon_token, input['account'])
        return self.perform_request('https://bankservices.rabobank.nl/auth/initiatelogondebitcard/v1',
                                    request_type='POST', raw_data=request_data, headers=self.get_rabo_headers()) \
            .addCallback(self.on_initiate_logon_response)

    def on_initiate_logon_response(self, response):
        tree = ET.ElementTree(ET.fromstring(response))
        challenge_url = tree.find('.//{https://bankservices.rabobank.nl/auth/initiatelogondebitcard/v1/'
                                  'response}ChallengeUrl').text
        return self.perform_request('https://bankservices.rabobank.nl/auth/initiatelogondebitcard/v1/%s'
                                    % challenge_url).addCallback(self.on_register_challenge_response)

    def on_register_challenge_response(self, response):
        image_data = response
        with open(os.path.join(self.cache_dir, 'rabo_challenge.png'), 'wb') as fp:
            fp.write(image_data)

        required_input = RequiredInput('rabo_register_challenge_response',
                                       [RequiredField('challenge', 'text',
                                                      'Please enter the response of the challenge')],
                                       additional_data={'image': b64encode(image_data)})
        return self.input_handler(required_input).addCallback(self.on_entered_registration_challenge_response)

    def on_entered_registration_challenge_response(self, input):
        request_data = '<?xml version="1.0" encoding="UTF-8" ?><ExecuteLogonDebitCard xmlns="https://bankservices.' \
                       'rabobank.nl/auth/executelogondebitcard/v1/request"><UserAuthenticationCode>%s' \
                       '</UserAuthenticationCode></ExecuteLogonDebitCard>' % input['challenge']
        return self.perform_request('https://bankservices.rabobank.nl/auth/executelogondebitcard/v1',
                                    request_type='POST', raw_data=request_data, headers=self.get_rabo_headers())\
            .addCallback(self.on_submit_challenge_response) \
            .addErrback(self.on_submit_challenge_error)

    def on_submit_challenge_response(self, response):
        request_data = '<?xml version="1.0" encoding="UTF-8" ?><createOfferRequest xmlns="http://www.rabobank.nl/' \
                       'online/service/signing"><data><property name="investment">false</property></data>' \
                       '<subject>subscribe</subject></createOfferRequest>'
        return self.perform_request('https://bankservices.rabobank.nl/services/signing/subscribe/offer',
                                    request_type='POST', raw_data=request_data, headers=self.get_rabo_headers()) \
            .addCallback(self.on_offer_request_response)

    def on_submit_challenge_error(self, failure):
        self._logger.debug("Login challlenge failed, trying again")
        with open(os.path.join(self.cache_dir, 'rabo_challenge.png'), 'r') as challenge_file:
            image_data = challenge_file.read()

        required_input = RequiredInput('rabo_register_challenge_response',
                                       [RequiredField('challenge', 'text',
                                                      'Please enter the response of the challenge')],
                                       additional_data={'image': b64encode(image_data)},
                                       error_text='Invalid challenge response entered')
        return self.input_handler(required_input).addCallback(self.on_entered_registration_challenge_response)

    def on_offer_request_response(self, response):
        namespace = 'http://www.rabobank.nl/online/service/signing'

        tree = ET.ElementTree(ET.fromstring(response))
        challenge_url = tree.find('.//{%s}image/{%s}url' % (namespace, namespace)).text
        self.offer_uid = tree.find('.//{%s}offerUid' % namespace).text

        # Fetch second challenge
        return self.perform_request('https://bankservices.rabobank.nl/services/signing/subscribe/%s'
                                    % challenge_url).addCallback(self.on_register_second_challenge_response)

    def on_register_second_challenge_response(self, response):
        image_data = response
        with open(os.path.join(self.cache_dir, 'rabo_challenge.png'), 'wb') as fp:
            fp.write(image_data)

        required_input = RequiredInput('rabo_register_second_challenge_response',
                                       [RequiredField('challenge', 'text',
                                                      'Please enter the response of the challenge')],
                                       additional_data={'image': b64encode(image_data)})
        return self.input_handler(required_input).addCallback(self.on_entered_second_registration_challenge_response)

    def on_entered_second_registration_challenge_response(self, input):
        request_data = '<?xml version="1.0" encoding="UTF-8" ?><signOfferRequest xmlns="http://www.rabobank.nl/' \
                       'online/service/signing"><userVerificationCode>%s</userVerificationCode>' \
                       '<offerUid>%s</offerUid></signOfferRequest>' % (input['challenge'], self.offer_uid)
        return self.perform_request('https://bankservices.rabobank.nl/services/signing/subscribe/offer/sign?uid=%s' %
                                    self.offer_uid, request_type='POST', raw_data=request_data,
                                    headers=self.get_rabo_headers())\
            .addCallback(self.on_submit_second_challenge_response) \
            .addErrback(self.on_submit_second_challenge_error)

    def on_submit_second_challenge_response(self, response):
        return self.perform_request(
            'https://bankservices.rabobank.nl/services/deviceregistration/v1', headers=self.get_rabo_headers()) \
            .addCallback(self.on_device_registration_response)

    def on_submit_second_challenge_error(self, failure):
        self._logger.debug("Second challlenge failed, trying again")
        with open(os.path.join(self.cache_dir, 'rabo_challenge.png'), 'r') as challenge_file:
            image_data = challenge_file.read()

        required_input = RequiredInput('rabo_second_challenge_response',
                                       [RequiredField('challenge', 'text',
                                                      'Please enter the response of the challenge')],
                                       additional_data={'image': b64encode(image_data)},
                                       error_text='Invalid challenge response entered')
        return self.input_handler(required_input).addCallback(self.on_entered_second_registration_challenge_response)

    def on_device_registration_response(self, response):
        # Write the cookies
        self.cookie_jar.save(os.path.join(self.cache_dir, 'rabo_cookies'))

        # Get the accounts and save the IBAN number
        return self.get_accounts().addCallback(self.on_post_register_accounts)

    def on_post_register_accounts(self, accounts):
        # Get and store the IBAN account number since we need it later
        namespace = 'https://bankservices.rabobank.nl/services/productoverview/v4/response'
        tree = ET.ElementTree(ET.fromstring(accounts))
        accounts = tree.findall('.//{%s}Accounts/{%s}Account' % (namespace, namespace))
        for account in accounts:
            if account.find('{%s}Number' % namespace).text == self.persistent_storage['account_number']:
                self.persistent_storage['account_iban'] = account.find('{%s}IBAN' % namespace).text
                self.persistent_storage['registered'] = True
                self.logged_in = True
                self.save_storage()

    #
    # Login
    #

    def login(self):
        if not self.is_registered():
            return fail(Failure(NotRegisteredException()))

        self.database.log_event('info', 'Starting login sequence for %s' % self.get_bank_name())
        request_data = '<?xml version="1.0" encoding="UTF-8" ?><LogonInfo xmlns="https://bankservices.rabobank.nl' \
                       '/auth/logoninfo/v1/request"><RequestedService>https://bankservices.rabobank.nl/services/' \
                       'balanceview/v1</RequestedService><EntranceCode>%s</EntranceCode></LogonInfo>' \
                       % time.strftime('%Y%m%d%H%M', time.gmtime())
        return self.perform_request('https://bankservices.rabobank.nl/auth/logoninfo/v1',
                                    request_type='POST', raw_data=request_data, headers=self.get_rabo_headers()) \
            .addCallback(self.on_logon_info)

    def on_logon_info(self, response):
        tree = ET.ElementTree(ET.fromstring(response))
        self.logon_token = tree.find('.//{https://bankservices.rabobank.nl/auth/logoninfo/v1/response}LogonToken').text

        if 'access_token' not in self.persistent_storage:
            required_input = RequiredInput('rabo_login_info',
                                           [RequiredField('access_token', 'text',
                                                          'Please enter your Rabobank access token')])
            return self.input_handler(required_input).addCallback(self.on_entered_access_token)
        else:
            return self.on_entered_access_token({'access_token': self.persistent_storage['access_token']})

    def on_entered_access_token(self, input):
        request_data = '<?xml version="1.0" encoding="UTF-8" ?><LogonAc xmlns="https://bankservices.rabobank.nl' \
                       '/auth/logonac/v2/request"><LogonToken>%s</LogonToken><BankAccountNumber>%s' \
                       '</BankAccountNumber><AccessCode>%s</AccessCode></LogonAc>'\
                       % (self.logon_token, str(self.persistent_storage['account_number']), str(input['access_token']))
        return self.perform_request('https://bankservices.rabobank.nl/auth/logonac/v2',
                                    request_type='POST', raw_data=request_data, headers=self.get_rabo_headers()) \
            .addCallback(lambda response: self.on_logged_in(response, input['access_token']))\
            .addErrback(self.on_login_error)

    def on_logged_in(self, response, access_token):
        # Save the access token, it seems to be correct
        self.persistent_storage['access_token'] = access_token
        self.save_storage()

        self.logged_in = True

    def on_login_error(self, failure):
        required_input = RequiredInput('rabo_login_info',
                                       [RequiredField('access_token', 'text',
                                                      'Please enter your Rabobank access token')],
                                       error_text='Invalid access code entered')
        return self.input_handler(required_input).addCallback(self.on_entered_access_token)

    #
    # Get accounts
    #

    def get_accounts(self):
        """
        Get information about your accounts.
        :return: A deferred that fires with information about your accounts.
        """
        return self.perform_request('https://bankservices.rabobank.nl/services/productoverview/v4',
                                    headers=self.get_rabo_headers())

    #
    # Balance
    #

    def get_balance(self):
        """
        Fetch the balance of a Rabobank account.
        :return: A deferred that fires with a dictionary containing the balance when successful.
        """
        self.database.log_event('info', 'Fetching balance for %s, account %s' %
                                (self.get_bank_name(), self.get_address()))

        def on_accounts(accounts):
            namespace = 'https://bankservices.rabobank.nl/services/productoverview/v4/response'
            tree = ET.ElementTree(ET.fromstring(accounts))
            accounts = tree.findall('.//{%s}Accounts/{%s}Account' % (namespace, namespace))
            for account in accounts:
                if account.find('{%s}IBAN' % namespace).text == self.persistent_storage['account_iban']:
                    return {
                        'available': float(account.find('{%s}Balance' % namespace).text),
                        'pending': 0.0,
                        'currency': account.find('{%s}Currency' % namespace).text
                    }

        return self.check_login().addCallback(lambda _: self.get_accounts()).addCallback(on_accounts)

    #
    # Get transactions
    #

    def get_transactions(self):
        """
        Fetch the most recent transactions of a Rabobank account.
        :return: A deferred that fires with a list containing transactions.
        """
        self.database.log_event('info', 'Fetching %s transactions of account %s' %
                                (self.get_bank_name(), self.get_address()))

        def perform_transactions_request(_):
            request_data = '<?xml version="1.0" encoding="UTF-8" ?><TransactionInformation xmlns="https://bankservices.' \
                           'rabobank.nl/services/transactioninformation/v2/request"><Currency>EUR</Currency>' \
                           '<NumberOfTransactions>10</NumberOfTransactions><ProductNumber>%s</ProductNumber>' \
                           '</TransactionInformation>' % str(self.persistent_storage['account_number'])
            return self.perform_request('https://bankservices.rabobank.nl/services/transactioninformation/v2',
                                        request_type='POST', raw_data=request_data, headers=self.get_rabo_headers()) \
                .addCallback(self.on_received_transactions)
        return self.check_login().addCallback(perform_transactions_request)

    def on_received_transactions(self, response):
        namespace = 'https://bankservices.rabobank.nl/services/transactioninformation/v2/response'
        tree = ET.ElementTree(ET.fromstring(response))
        transactions = tree.findall('.//{%s}Transactions/{%s}Transaction' % (namespace, namespace))
        transactions_list = []
        for transaction in transactions:
            amount = float(transaction.find('{%s}Amount' % namespace).text)
            outgoing = amount < 0
            if outgoing:
                from_account = self.persistent_storage['account_iban']
                to_account = transaction.find('{%s}BeneficiaryAccount' % namespace).text
            else:
                from_account = transaction.find('{%s}BeneficiaryAccount' % namespace).text
                to_account = self.persistent_storage['account_iban']

            description_str = ''
            descriptions_elem = transaction.find('{%s}Descriptions' % namespace)
            if descriptions_elem is not None:
                for description_elem in descriptions_elem.findall('{%s}Description' % namespace):
                    description_str += description_elem.text + '\n'

            transactions_list.append({
                'id': '',
                'outgoing': outgoing,
                'from': str(from_account),
                'to': str(to_account),
                'amount': abs(amount),
                'fee_amount': 0.0,
                'currency': str(transaction.find('{%s}Currency' % namespace).text),
                'timestamp': str(transaction.find('{%s}BookDate' % namespace).text),
                'description': str(description_str.rstrip())
            })

        return transactions_list

    #
    #  Payments
    #

    def make_payment(self):
        """
        Initiate a new payment by asking the user for payment details.
        """
        required_input = RequiredInput('rabo_payment_info', RaboManager.get_payment_info_fields())
        return self.input_handler(required_input).addCallback(self.on_entered_payment_details)

    def on_entered_payment_details(self, input):
        return self.perform_payment(input['amount'], input['destination_account'], input['description'])

    def perform_payment(self, amount, destination_account, description):
        """
        Perform a payment.
        :param amount: the amount of money to transfer, in euro (i.e. 3.14).
        :param destination_account: the destination of the payment.
        :param description: an optional description that is appended to the payment.
        :return: A deferred that fires with a transaction id when the payment has been successful.
        """
        self.database.log_event('info', 'Starting %s payment with amount %f to %s (description: %s)' %
                                (self.get_bank_name(), float(amount), destination_account, description))

        payment = {'amount': amount, 'from_iban': self.get_address(), 'to_iban': destination_account,
                   'description': description}

        request_data = '<?xml version="1.0" encoding="UTF-8" ?><ValidateTransaction xmlns="' \
                       'https://bankservices.rabobank.nl/services/validatetransaction/v2/request"><Transaction>' \
                       '<BeneficiaryName>%s</BeneficiaryName><BeneficiaryAccount>%s</BeneficiaryAccount>' \
                       '<Description>%s</Description><FromAccount>%s</FromAccount><Currency>EUR</Currency>' \
                       '<Amount>%s</Amount><ExecutionDate>%s</ExecutionDate></Transaction></ValidateTransaction>' % \
                       ('Receiver', str(destination_account), str(description),
                        str(self.persistent_storage['account_iban']), str(int(float(amount) * 100)),
                        time.strftime('%Y-%m-%d', time.gmtime()))

        return self.perform_request('https://bankservices.rabobank.nl/services/validatetransaction/v2',
                                    request_type='POST', raw_data=request_data, headers=self.get_rabo_headers()) \
            .addCallback(lambda response: self.on_received_transaction_validation(response, payment))

    def on_received_transaction_validation(self, response, payment):
        request_data = '<?xml version="1.0" encoding="UTF-8" ?><SubmitTransaction xmlns="' \
                       'https://bankservices.rabobank.nl/services/submittransaction/v3/request"><Transaction>' \
                       '<BeneficiaryName>%s</BeneficiaryName><BeneficiaryAccount>%s</BeneficiaryAccount>' \
                       '<Description>%s</Description><FromAccount>%s</FromAccount><Currency>EUR</Currency>' \
                       '<Amount>%s</Amount><ExecutionDate>%s</ExecutionDate></Transaction></SubmitTransaction>' % \
                       ('Receiver', str(payment['to_iban']), str(payment['description']),
                        str(self.persistent_storage['account_iban']), str(payment['amount']),
                        time.strftime('%Y-%m-%d', time.gmtime()))

        return self.perform_request('https://bankservices.rabobank.nl/services/submittransaction/v3',
                                    request_type='POST', raw_data=request_data, headers=self.get_rabo_headers()) \
            .addCallback(lambda response: self.on_received_transaction_submit(response, payment))

    def on_received_transaction_submit(self, response, payment):
        tree = ET.ElementTree(ET.fromstring(response))
        transaction_key = tree.find('.//{https://bankservices.rabobank.nl/services/submittransaction/v3/'
                                    'response}TransactionKey').text

        # Sign the offer
        request_data = '<?xml version="1.0" encoding="UTF-8" ?><createOfferRequest xmlns="' \
                       'http://www.rabobank.nl/online/service/signing"><data>' \
                       '<property name="transactionKey">%s</property></data><subject>transfer</subject>' \
                       '</createOfferRequest>' % str(transaction_key)

        return self.perform_request('https://bankservices.rabobank.nl/services/signing/transfer/offer',
                                    request_type='POST', raw_data=request_data, headers=self.get_rabo_headers()) \
            .addCallback(lambda response: self.on_received_sign_offer(response, payment))

    def on_received_sign_offer(self, response, payment):
        tree = ET.ElementTree(ET.fromstring(response))
        offer_uid = tree.find('.//{http://www.rabobank.nl/online/service/signing}offerUid').text

        request_data = '<?xml version="1.0" encoding="UTF-8" ?><signOfferRequest xmlns="' \
                       'http://www.rabobank.nl/online/service/signing"><offerUid>%s</offerUid>' \
                       '</signOfferRequest>' % str(offer_uid)

        return self.perform_request('https://bankservices.rabobank.nl/services/signing/transfer/offer/sign?uid=%s' %
                                    offer_uid,
                                    request_type='POST', raw_data=request_data, headers=self.get_rabo_headers()) \
            .addCallback(lambda response: self.on_sign_transfer_response(response, payment))

    def on_sign_transfer_response(self, response, payment):
        txid = str(self.offer_uid)
        self.database.add_transaction(txid, payment['from_iban'], payment['to_iban'], payment['amount'],
                                      payment['description'])
        return txid
