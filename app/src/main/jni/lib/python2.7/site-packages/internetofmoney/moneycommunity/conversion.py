from dispersy.conversion import BinaryConversion
from dispersy.message import DropPacket
from internetofmoney.utils.encoding import encode, decode


class MoneyConversion(BinaryConversion):

    def __init__(self, community):
        super(MoneyConversion, self).__init__(community, "\x01")
        self.define_meta_message(chr(1), community.get_meta_message(u"services-info"),
                                 self._encode_services_info, self._decode_services_info)
        self.define_meta_message(chr(2), community.get_meta_message(u"capacity-query"),
                                 self._encode_capacity_query, self._decode_capacity_query)
        self.define_meta_message(chr(3), community.get_meta_message(u"capacity-response"),
                                 self._encode_capacity_response, self._decode_capacity_response)
        self.define_meta_message(chr(4), community.get_meta_message(u"payment-to-switch"),
                                 self._encode_payment_to_switch, self._decode_payment_to_switch)
        self.define_meta_message(chr(5), community.get_meta_message(u"payment-from-switch"),
                                 self._encode_payment_from_switch, self._decode_payment_from_switch)
        self.define_meta_message(chr(6), community.get_meta_message(u"rollback"),
                                 self._encode_rollback, self._decode_rollback)

    def _decode_payload(self, placeholder, offset, data, types):
        try:
            offset, payload = decode(data, offset)
        except ValueError:
            raise DropPacket("Unable to decode the payload")

        if not isinstance(payload, tuple):
            raise DropPacket("Invalid payload type")

        args = []
        cur_ind = 0
        for arg_type in types:
            try:
                if arg_type == str or arg_type == int:
                    args.append(payload[cur_ind])
                    cur_ind += 1
                else:
                    args.append(arg_type(payload[cur_ind]))
                    cur_ind += 1
            except ValueError:
                raise DropPacket("Invalid '" + arg_type.__name__ + "' type")
        return offset, placeholder.meta.payload.implement(*args)

    def _encode_services_info(self, message):
        packet = encode((message.payload.services_map, message.payload.tx_fee))
        return packet,

    def _decode_services_info(self, placeholder, offset, data):
        return self._decode_payload(placeholder, offset, data, [dict, float])

    def _encode_capacity_query(self, message):
        packet = encode((message.payload.identifier, message.payload.bank_id, message.payload.amount))
        return packet,

    def _decode_capacity_query(self, placeholder, offset, data):
        return self._decode_payload(placeholder, offset, data, [int, str, float])

    def _encode_capacity_response(self, message):
        packet = encode((message.payload.identifier, message.payload.has_enough))
        return packet,

    def _decode_capacity_response(self, placeholder, offset, data):
        return self._decode_payload(placeholder, offset, data, [int, bool])

    def _encode_payment_to_switch(self, message):
        packet = encode((message.payload.identifier, message.payload.to_switch_txid, message.payload.from_switch_txid,
                         message.payload.from_iban, message.payload.to_iban, message.payload.final_destination_iban,
                         message.payload.amount))
        return packet,

    def _decode_payment_to_switch(self, placeholder, offset, data):
        return self._decode_payload(placeholder, offset, data, [int, str, str, str, str, str, float])

    def _encode_payment_from_switch(self, message):
        packet = encode((message.payload.identifier,))
        return packet,

    def _decode_payment_from_switch(self, placeholder, offset, data):
        return self._decode_payload(placeholder, offset, data, [int])

    def _encode_rollback(self, message):
        packet = encode((message.payload.identifier, message.payload.reason,))
        return packet,

    def _decode_rollback(self, placeholder, offset, data):
        return self._decode_payload(placeholder, offset, data, [int, str])
