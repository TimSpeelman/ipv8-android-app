import inspect
import os
import shutil
import unittest

import functools
from tempfile import mkdtemp

import logging
from twisted.internet import interfaces
from twisted.internet.base import BasePort
from twisted.internet.defer import inlineCallbacks
from twisted.internet.task import deferLater
from twisted.internet.tcp import Client
from twisted.web.http import HTTPChannel

from dispersy.util import blocking_call_on_reactor_thread
from internetofmoney.session import Session
from internetofmoney.tests.util.exc_util import process_unhandled_exceptions, process_unhandled_twisted_exceptions
from twisted.plugins.internet_of_money import Options

from internetofmoney.tests.util.twisted_thread import reactor


class BaseTestCase(unittest.TestCase):

    def __init__(self, *args, **kwargs):
        super(BaseTestCase, self).__init__(*args, **kwargs)

        self._logger = logging.getLogger(self.__class__.__name__)
        self.temp_dir = None

        def wrap(fun):
            @functools.wraps(fun)
            def check(*argv, **kwargs):
                try:
                    result = fun(*argv, **kwargs)
                except:
                    raise
                else:
                    process_unhandled_exceptions()
                return result
            return check

        for name, method in inspect.getmembers(self, predicate=inspect.ismethod):
            if name.startswith("test_"):
                setattr(self, name, wrap(method))

    @blocking_call_on_reactor_thread
    @inlineCallbacks
    def checkReactor(self, phase, *_):
        delayed_calls = reactor.getDelayedCalls()
        if delayed_calls:
            self._logger.error("The reactor was dirty during %s:", phase)
            for dc in delayed_calls:
                self._logger.error(">     %s" % dc)
                dc.cancel()

        has_network_selectables = False
        for item in reactor.getReaders() + reactor.getWriters():
            if isinstance(item, HTTPChannel) or isinstance(item, Client):
                has_network_selectables = True
                break

        if has_network_selectables:
            # TODO(Martijn): we wait a while before we continue the check since network selectables
            # might take some time to cleanup. I'm not sure what's causing this.
            yield deferLater(reactor, 0.2, lambda: None)

        # This is the same check as in the _cleanReactor method of Twisted's Trial
        selectable_strings = []
        for sel in reactor.removeAll():
            if interfaces.IProcessTransport.providedBy(sel):
                self._logger.error("Sending kill signal to %s", repr(sel))
                sel.signalProcess('KILL')
            selectable_strings.append(repr(sel))

        self.assertFalse(delayed_calls, "The reactor was dirty during %s" % phase)

        self.assertFalse(selectable_strings,
                         "The reactor has leftover readers/writers during %s: %r" % (phase, selectable_strings))

        # Check whether we have closed all the sockets
        open_readers = reactor.getReaders()
        for reader in open_readers:
            self.assertNotIsInstance(reader, BasePort,
                                     "Listening ports left on the reactor during %s: %s" % (phase, reader))

        # Check whether the threadpool is clean
        self.assertEqual(len(reactor.getThreadPool().working), 0, "Still items left in the threadpool")

    @blocking_call_on_reactor_thread
    @inlineCallbacks
    def setUp(self):
        self.temp_dir = mkdtemp(suffix="_iom_test")
        yield self.checkReactor(phase="setUp")

    @blocking_call_on_reactor_thread
    @inlineCallbacks
    def tearDown(self):
        yield self.checkReactor(phase="tearDown")
        process_unhandled_exceptions()
        process_unhandled_twisted_exceptions()
        shutil.rmtree(unicode(self.temp_dir), ignore_errors=True)


class SessionTestCase(BaseTestCase):
    """
    This class is the base class to use when testing a Session.
    """

    def __init__(self, *args, **kwargs):
        super(SessionTestCase, self).__init__(*args, **kwargs)

        self.session = None

    @blocking_call_on_reactor_thread
    @inlineCallbacks
    def setUp(self):
        yield super(SessionTestCase, self).setUp()

        options = Options()
        Options.parseOptions(options, ['-d', '--cache', self.temp_dir])
        self.session = Session(options)
        self.session.start()

    @blocking_call_on_reactor_thread
    @inlineCallbacks
    def tearDown(self):
        yield self.session.stop()
        yield super(SessionTestCase, self).tearDown()
