import json
import time
from urllib import urlencode, quote_plus

from internetofmoney.RequiredField import RequiredField
from internetofmoney.RequiredInput import RequiredInput
from twisted.internet.defer import inlineCallbacks, returnValue

from internetofmoney.managers.paypal.PayPalBaseManager import PayPalBaseManager


class PayPalManager(PayPalBaseManager):
    """
    This class implements the manager used to communicate with the PayPal server.
    """

    def get_address(self):
        return self.persistent_storage['email']

    @staticmethod
    def get_login_fields():
        """
        Return the fields required for logging in to PayPal.
        """
        email_field = RequiredField('email', 'text', 'Please enter your PayPal email', 'PayPal email')
        password_field = RequiredField('password', 'password', 'Please enter your PayPal password', 'PayPal password')
        return [email_field, password_field]

    @staticmethod
    def get_payment_info_fields():
        """
        Return the fields required for making a payment in PayPal.
        """
        amount_field = RequiredField('amount', 'text', 'Please enter the amount of money to transfer')
        destination_field = RequiredField('destination_account', 'text', 'Please enter the destination email address')
        description_field = RequiredField('description', 'text', 'Please an optional payment description')
        return [amount_field, destination_field, description_field]

    def login(self):
        """
        Login to a PayPal account. This method uses the credentials stored in the persistent storage and if they
        are not available, they are asked to the user.
        """
        self.database.log_event('info', 'Starting login sequence for %s' % self.get_bank_name())
        if 'password' in self.persistent_storage and 'email' in self.persistent_storage:
            return self.login_with_credentials(str(self.persistent_storage['email']),
                                               str(self.persistent_storage['password']))
        else:
            required_input = RequiredInput('paypal_credentials', PayPalManager.get_login_fields())
            return self.input_handler(required_input).addCallback(self.on_entered_credentials)

    def on_entered_credentials(self, input):
        return self.login_with_credentials(input['email'], input['password'])

    def login_with_credentials(self, email, password):
        """
        Login to a PayPal account with a specified email/password.
        :param email: The mail address of the PayPal account.
        :param password: The password of the mail account.
        :return: A deferred that fires when the login operation has been successful.
        """
        app_info = {'device_app_id': 'com.yourcompany.PPClient', 'client_platform': 'Apple',
                    'app_version': '6.11.0', 'app_category': 3}
        device_info = {"device_identifier": self.guid,
                       "device_name": "iPhone",
                       "device_type": "iPhone",
                       "device_key_type": "Unknown",
                       "device_model": "iPhone",
                       "device_os": "iPhone OS",
                       "device_os_version": "10.3",
                       "is_device_simulator": False,
                       "pp_app_id": "APP-3P637985EF709422H"}
        risk_data = {"app_guid": self.guid}

        timestamp = int(round(time.time() * 1000))
        request_dict = {
            'appInfo': json.dumps(app_info),
            'adsChallengeId': 'auth-%s' % self.guid,
            'password': password,
            'rememberMe': 'false',
            'grantType': 'password',
            'authNonce': self.generate_auth_nonce(timestamp, email, password),
            'firstPartyClientId': 'd3aacf450dd6aa992cfba77067560733',
            'redirectUri': 'urn:ietf:wg:oauth:2.0:oob',
            'email': email,
            'timeStamp': timestamp,
            'deviceInfo': json.dumps(device_info),
            'riskData': json.dumps(risk_data)
        }

        return self.perform_request('https://api-m.paypal.com/v1/mfsauth/proxy-auth/token',
                                    request_type='POST', raw_data=urlencode(request_dict).replace('+', '%20'),
                                    headers=self.get_paypal_headers())\
            .addCallback(lambda response: self.on_access_token(response, email, password))\
            .addErrback(self.on_access_token_error)

    def on_access_token(self, response, email, password):
        self.logged_in = True
        response = json.loads(response)
        self.access_token = str(response['result']['firstPartyUserAccessToken']['tokenValue'])

        self.persistent_storage['email'] = email
        self.persistent_storage['password'] = password
        self.save_storage()

    def on_access_token_error(self, failure):
        self._logger.error("PayPal access token request failed: %s", failure)
        required_input = RequiredInput('paypal_credentials', PayPalManager.get_login_fields(),
                                       error_text='PayPal login failed')
        return self.input_handler(required_input).addCallback(self.on_entered_credentials)

    #
    # Balance
    #

    def get_balance(self):
        """
        Fetch the balance of a PayPal account.
        :return: A deferred that fires with a dictionary containing the balance when successful.
        """
        self.database.log_event('info', 'Fetching balance for %s, account %s' %
                                (self.get_bank_name(), self.get_address()))

        def perform_balance_request(_):
            return self.perform_request('https://api-m.paypal.com/v1/mfsconsumer/wallet/@me/balance',
                                        headers=self.get_paypal_headers()).addCallback(self.on_balance)
        return self.check_login().addCallback(perform_balance_request)

    def on_balance(self, response):
        balance_json = json.loads(response)
        return {
            'pending': float(balance_json['result']['currencyBalances'][0]['pending']['value']) / 100.0,
            'available': float(balance_json['result']['currencyBalances'][0]['available']['value']) / 100.0,
            'currency': str(balance_json['result']['currencyBalances'][0]['available']['currencyCode'])
        }

    #
    # Transactions
    #

    def get_transaction_details(self, transaction_id):
        """
        Fetch detailed information of a transaction.
        :param transaction_id: the id of the transaction.
        :return: A deferred that fires with a dictionary with transaction details.
        """
        request_url = "https://api-m.paypal.com/v1/mfsconsumer/activity-details/%s" % str(transaction_id)
        return self.perform_request(request_url, headers=self.get_paypal_headers())\
            .addCallback(self.on_transaction_details)

    def on_transaction_details(self, response):
        return json.loads(response)

    def get_transactions(self):
        """
        Fetch the 15 most recent transactions of a PayPal account.
        :return: A deferred that fires with a list containing transactions.
        """
        self.database.log_event('info', 'Fetching %s transactions of account %s' %
                                (self.get_bank_name(), self.get_address()))

        def perform_transactions_request(_):
            filter_json = [{
                "filterId": "D86EA391-7185-4BF7-B633-C3D18309B06D",
                "hideRedundantTransactions": True,
                "group": "Completed",
                "limit": 15,
            }]
            filters_encoded = quote_plus(json.dumps(filter_json))
            request_url = 'https://api-m.paypal.com/v1/mfsconsumer/activity-summary-list?filters=%s' % filters_encoded
            return self.perform_request(request_url, headers=self.get_paypal_headers()).addCallback(self.on_transactions)
        return self.check_login().addCallback(perform_transactions_request)

    @inlineCallbacks
    def on_transactions(self, response):
        json_response = json.loads(response)
        transactions_dict = []

        for transaction in json_response['result']['filteredItemList'][0]['activityItems'][:5]:
            transaction_id = transaction['domainObject']['uniqueId']
            is_payer = True
            if 'email' in transaction['domainObject']['payer'] and transaction['domainObject']['payer'] != self.persistent_storage['email']:
                is_payer = False

            if is_payer:
                from_email = self.persistent_storage['email']
                to_email = transaction['domainObject']['recipient']['email']
            else:
                from_email = transaction['domainObject']['payer']['email']
                to_email = self.persistent_storage['email']

            amount = float(transaction['domainObject']['grossAmount']['value']) / float(transaction['domainObject']['grossAmount']['scale'])
            fee_amount = float(transaction['domainObject']['feeAmount']['value']) / float(transaction['domainObject']['feeAmount']['scale'])

            # We now fetch the transaction details if necessary
            if transaction_id in self.known_descriptions:
                note = self.known_descriptions[transaction_id]
            else:
                transaction_details = yield self.get_transaction_details(transaction['domainObject']['uniqueId'])
                note = ''
                if 'note' in transaction_details['result']['domainObject']:
                    note = transaction_details['result']['domainObject']['note']
                self.known_descriptions[transaction_id] = note

            transactions_dict.append({
                'id': str(transaction_id),
                'outgoing': True if is_payer else False,
                'from': str(from_email),
                'to': str(to_email),
                'amount': amount,
                'fee_amount': fee_amount,
                'currency': transaction['domainObject']['grossAmount']['currencyCode'],
                'timestamp': str(transaction['timeCreated']),
                'description': note
            })

        returnValue(transactions_dict)

    #
    # Payments
    #

    def make_payment(self):
        """
        Initiate a new payment by asking the user for payment details.
        """
        required_input = RequiredInput('paypal_payment_info', PayPalManager.get_payment_info_fields())
        return self.input_handler(required_input).addCallback(self.on_entered_payment_details)

    def on_entered_payment_details(self, input):
        return self.perform_payment(input['amount'], input['destination_account'], input['description'])

    def perform_payment(self, amount, destination_account, description):
        """
        Perform a payment.
        :param amount: the amount of money to transfer, in euro (i.e. 3.14).
        :param destination_account: the destination of the payment.
        :param description: an optional description that is appended to the payment.
        :return: A deferred that fires with a transaction id when the payment has been successful.
        """
        self.database.log_event('info', 'Starting %s payment with amount %f to %s (description: %s)' %
                                (self.get_bank_name(), float(amount), destination_account, description))

        request_dict = {
            "amount": {
                "value": int(float(amount) * 100),
                "currencyCode": "EUR"
            },
            "type": "Personal",
            "payee": {
                "type": "Email",
                "email": destination_account
            }
        }

        return self.perform_request('https://api-m.paypal.com/v1/mfsconsumer/transfers/to_send-money/submission_for_receipt',
                                    request_type='POST', raw_data=json.dumps(request_dict),
                                    headers=self.get_paypal_headers(is_json=True))\
            .addCallback(lambda response: self.on_payment_receipt(response, amount, description, destination_account))

    def on_payment_receipt(self, response, amount, description, destination_account):
        json_response = json.loads(response)

        # Now send the payment
        request_dict = {
            "type": "Personal",
            "payee": {
                "type": "Email",
                "email": destination_account
            },
            "sendMoneyFundingMix": json_response["result"]["sendMoneyFundingMixSelectionChallengeItems"][0]["sendMoneyFundingMix"],
            "amount": {
                "value": int(float(amount) * 100),
                "currencyCode": "EUR"
            }
        }

        if description:
            request_dict["note"] = description

        return self.perform_request('https://api-m.paypal.com/v1/mfsconsumer/transfers/to_send-money/funding-mix_for_receipt',
            request_type='POST', raw_data=json.dumps(request_dict),
            headers=self.get_paypal_headers(is_json=True)).addCallback(
            lambda resp: self.on_payment_response(description, response))

    def on_payment_response(self, description, response):
        json_response = json.loads(response)
        destination_account = json_response['result']['payee']['email']
        amount = float(json_response['result']['amount']['value']) / float(json_response['result']['amount']['scale'])
        txid = str(json_response['result']['transactionId'])
        self.database.add_transaction(txid, self.get_address(), destination_account, amount, description)
        return str(json_response['result']['transactionId'])
