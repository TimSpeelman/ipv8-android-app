import json
import logging

from twisted.web import http
from twisted.web import resource
from twisted.web.resource import NoResource
from twisted.web.server import NOT_DONE_YET

from internetofmoney.restapi.util import return_handled_exception
from internetofmoney.utils.exceptions import WalletLockedException


class AbstractSpecificBankEndpoint(resource.Resource):

    def __init__(self, bank_manager):
        resource.Resource.__init__(self)
        self.bank_manager = bank_manager
        self._logger = logging.getLogger(self.__class__.__name__)

    def on_failure(self, request, failure):
        """
        Error callback
        """
        self._logger.exception(failure)
        request.write(return_handled_exception(request, failure.value))
        request.finish()

    @staticmethod
    def check_parameters(parameters, required_parameters):
        """
        Check that all required parameters are in the parameters array. If not, return a human-readable string that
        specifies which parameters are missing.
        """
        for req_param in required_parameters:
            if req_param not in parameters or len(parameters[req_param]) == 0:
                return False, "%s parameter missing" % req_param
        return True, None


class BanksEndpoint(resource.Resource):
    """
    This class handles requests for bank services.
    """

    def __init__(self, session):
        resource.Resource.__init__(self)
        self.session = session

    def render_GET(self, request):
        """
        Return the available bank managers.
        """
        return json.dumps({"banks": self.session.managers.keys()})

    def getChild(self, path, request):
        if path not in self.session.managers:
            return NoResource()
        return SpecificBankEndpoint(self.session.managers[path])


class SpecificBankEndpoint(resource.Resource):
    """
    This class handles requests for specific bank services.
    """

    def __init__(self, bank_manager):
        resource.Resource.__init__(self)

        self.putChild("register", SpecificBankRegisterEndpoint(bank_manager))
        self.putChild("login", SpecificBankLoginEndpoint(bank_manager))
        self.putChild("balance", SpecificBankBalanceEndpoint(bank_manager))
        self.putChild("transactions", SpecificBankTransactionsEndpoint(bank_manager))
        self.putChild("payment", SpecificBankPaymentEndpoint(bank_manager))


class SpecificBankBalanceEndpoint(AbstractSpecificBankEndpoint):
    """
    This class handles requests for balance.
    """

    def render_GET(self, request):
        """
        Return the balance of a specific bank account.
        """
        if not self.bank_manager.storage_loaded:
            request.setResponseCode(http.UNAUTHORIZED)
            raise WalletLockedException()

        def on_balance(balance):
            request.write(json.dumps({'balance': balance}))
            request.finish()

        self.bank_manager.get_balance().addCallback(on_balance).addErrback(
            lambda failure: self.on_failure(request, failure))

        return NOT_DONE_YET


class SpecificBankRegisterEndpoint(AbstractSpecificBankEndpoint):
    """
    This class handles requests for registration.
    """

    def render_POST(self, request):
        """
        Register with a specific financial service provider.
        """
        if not self.bank_manager.storage_loaded:
            request.setResponseCode(http.UNAUTHORIZED)
            raise WalletLockedException()

        def on_registered(_):
            request.write(json.dumps({"registered": True}))
            request.finish()

        self.bank_manager.register().addCallback(on_registered)

        return NOT_DONE_YET


class SpecificBankLoginEndpoint(AbstractSpecificBankEndpoint):
    """
    This class handles requests for registration.
    """

    def render_POST(self, request):
        """
        Login with a specific financial service provider.
        """
        if not self.bank_manager.storage_loaded:
            request.setResponseCode(http.UNAUTHORIZED)
            raise WalletLockedException()

        def on_logged_in(_):
            request.write(json.dumps({"logged_in": True}))
            request.finish()

        self.bank_manager.login().addCallback(on_logged_in).addErrback(
            lambda failure: self.on_failure(request, failure))

        return NOT_DONE_YET


class SpecificBankTransactionsEndpoint(AbstractSpecificBankEndpoint):
    """
    This class handles requests for transaction history.
    """

    def render_GET(self, request):
        """
        Return the past transactions of a specific bank account.
        """
        if not self.bank_manager.storage_loaded:
            request.setResponseCode(http.UNAUTHORIZED)
            raise WalletLockedException()

        def on_transactions(transactions):
            request.write(json.dumps({"transactions": transactions}))
            request.finish()

        self.bank_manager.get_transactions().addCallback(on_transactions).addErrback(
            lambda failure: self.on_failure(request, failure))

        return NOT_DONE_YET


class SpecificBankPaymentEndpoint(AbstractSpecificBankEndpoint):
    """
    This class handles requests to make payments.
    """

    def render_POST(self, request):
        """
        Return the past transactions of a specific bank account.
        """
        if not self.bank_manager.storage_loaded:
            request.setResponseCode(http.UNAUTHORIZED)
            raise WalletLockedException()

        parameters = http.parse_qs(request.content.read(), 1)
        print parameters

        def on_payment_done(tx_id):
            request.write(json.dumps({"success": True, "payment_id": tx_id}))
            request.finish()

        if len(parameters) == 0:
            self.bank_manager.make_payment().addCallback(on_payment_done).addErrback(
                lambda failure: self.on_failure(request, failure))
        else:
            has_all, error_str = AbstractSpecificBankEndpoint.check_parameters(
                parameters, ['amount', 'destination_account', 'description'])
            if has_all:
                self.bank_manager.perform_payment(float(parameters['amount'][0]), parameters['destination_account'][0],
                                                  parameters['description'][0]).addCallback(on_payment_done)\
                    .addErrback(lambda failure: self.on_failure(request, failure))
            else:
                self.bank_manager.make_payment().addCallback(on_payment_done).addErrback(
                    lambda failure: self.on_failure(request, failure))

        return NOT_DONE_YET
