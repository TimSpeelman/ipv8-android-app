import hashlib
import os
import sys

import logging
import logging.handlers

from twisted.internet.defer import inlineCallbacks, succeed, Deferred
from twisted.python import log

from dispersy.discovery.community import BOOTSTRAP_FILE_ENVNAME
from dispersy.dispersy import Dispersy
from dispersy.endpoint import StandaloneEndpoint
from internetofmoney.database import InternetOfMoneyDB
from internetofmoney.managers.abn.ABNManager import ABNManager
from internetofmoney.managers.dummy.DummyManager import Dummy1Manager, Dummy3Manager, Dummy2Manager
from internetofmoney.managers.ing.INGManager import INGManager
from internetofmoney.managers.paypal.PayPalManager import PayPalManager
from internetofmoney.managers.rabo.RaboManager import RaboManager
from internetofmoney.moneychain.community import MoneyChainCommunity
from internetofmoney.moneycommunity.community import MoneyCommunity
from internetofmoney.restapi.rest_manager import RESTManager
from internetofmoney.utils import permid
from internetofmoney.utils.exceptions import WrongPasswordException, PasswordAlreadySetException


class Session(object):
    """
    This class represents an Internet-of-Money session.
    It contains methods to start, close and manage the session.
    """
    
    def __init__(self, options):
        self.options = options
        self.managers = {}
        self.money_community = None
        self.line_receiver = None
        self.database = None
        self.dispersy = None
        self.is_switch = False
        self.cache_dir = self.options['cache']
        self.api_manager = None
        self.input_deferreds = {}
        self.is_locked = True
        self.file_handler = None
        self.stream_handler = None

        # Make sure to use our own root certificates file
        dir_path = os.path.dirname(os.path.realpath(__file__))
        os.environ['SSL_CERT_FILE'] = os.path.join(dir_path, 'data', 'root_certs.pem')

    def start(self):
        if not os.path.exists(self.cache_dir):
            os.mkdir(self.cache_dir)

        # Setup the database
        self.database = InternetOfMoneyDB(self.cache_dir)

        self.init_logging()

        if self.options["switch"]:
            self.enable_switch()

        self.initialize_managers()

        # Start the HTTP API
        self.api_manager = RESTManager(self)
        self.api_manager.start(self.options['apiport'])

        for manager in self.managers.itervalues():
            manager.input_handler = self.input_handler

    @inlineCallbacks
    def stop(self):
        yield self.api_manager.stop()
        self.database.close()
        logging.getLogger().removeHandler(self.file_handler)
        logging.getLogger().removeHandler(self.stream_handler)

        if self.dispersy:
            yield self.dispersy.stop()
        yield succeed(None)

    def unlock(self, password):
        """
        Unlock the wallet using the provided password.
        """
        if not self.is_locked:
            return  # Already unlocked

        if not os.path.exists(os.path.join(self.cache_dir, 'pwhash')):
            raise RuntimeError("No password set!")

        with open(os.path.join(self.cache_dir, 'pwhash'), 'r') as hash_file:
            file_hash = hash_file.read()
            hex_hash = hashlib.sha1(bytes(password)).hexdigest()
            if file_hash != hex_hash:
                raise WrongPasswordException()

        for manager in self.managers.itervalues():
            manager.load_storage(password)

        self.is_locked = False

    def set_password(self, password):
        """
        Set the password for this wallet.
        """
        if os.path.exists(os.path.join(self.cache_dir, 'pwhash')):
            raise PasswordAlreadySetException()

        with open(os.path.join(self.cache_dir, 'pwhash'), 'w') as hash_file:
            hex_hash = hashlib.sha1(bytes(password)).hexdigest()
            hash_file.write(hex_hash)

        for manager in self.managers.itervalues():
            manager.load_storage(password)

    def input_handler(self, required_input):
        input_deferred = Deferred()
        self.input_deferreds[required_input.name] = input_deferred
        self.api_manager.root_endpoint.events_endpoint.send_input_request(required_input)
        return input_deferred

    def on_input(self, name, user_input):
        """
        This method is invoked when there is user input available.
        :param name: the name of the input, should match the name passed to iom_input_handler
        :type name: str
        :param user_input: a dictionary with the given user input.
        :type user_input: dict
        """
        if name not in self.input_deferreds:
            raise RuntimeError("Received input that we didn't expect!")

        self.input_deferreds[name].callback(user_input)
        del self.input_deferreds[name]
        
    def init_logging(self):
        # Initialize logging
        log.startLogging(sys.stdout)
        root = logging.getLogger()
        root.setLevel(logging.DEBUG)

        # Log critical messages to stderr
        self.stream_handler = logging.StreamHandler(sys.stderr)
        formatter = logging.Formatter('%(asctime)s - %(name)s - %(levelname)s - %(message)s')
        self.stream_handler.setFormatter(formatter)
        self.stream_handler.setLevel(logging.CRITICAL)
        root.addHandler(self.stream_handler)

        self.file_handler = logging.handlers.WatchedFileHandler(
            os.environ.get("LOGFILE", os.path.join(self.cache_dir, "iom.log")))
        self.file_handler.setFormatter(formatter)
        self.file_handler.setLevel(logging.DEBUG)
        root.addHandler(self.file_handler)

    def initialize_managers(self):
        paypal_manager = PayPalManager(self.database, cache_dir=self.cache_dir)
        rabo_manager = RaboManager(self.database, cache_dir=self.cache_dir)
        abn_manager = ABNManager(self.database, cache_dir=self.cache_dir)
        ing_manager = INGManager(self.database, cache_dir=self.cache_dir)
        self.managers = {
            paypal_manager.get_bank_id(): paypal_manager,
            rabo_manager.get_bank_id(): rabo_manager,
            abn_manager.get_bank_id(): abn_manager,
            ing_manager.get_bank_id(): ing_manager,
        }

        if self.options['dummy']:
            dummy1_manager = Dummy1Manager(self.database, cache_dir=self.cache_dir)
            dummy2_manager = Dummy2Manager(self.database, cache_dir=self.cache_dir)
            dummy3_manager = Dummy3Manager(self.database, cache_dir=self.cache_dir)

            self.managers[dummy1_manager.get_bank_id()] = dummy1_manager
            self.managers[dummy2_manager.get_bank_id()] = dummy2_manager
            self.managers[dummy3_manager.get_bank_id()] = dummy3_manager

    def load_money_community(self):
        keypair_path = os.path.join(self.cache_dir, 'ec.pem')
        if os.path.exists(keypair_path):
            keypair = permid.read_keypair(keypair_path)
        else:
            keypair = permid.generate_keypair()
            permid.save_keypair(keypair, keypair_path)
        master_member = self.dispersy.get_member(private_key=keypair.key_to_bin())
        chain_community = self.dispersy.define_auto_load(MoneyChainCommunity, master_member, load=True, kargs={})[0]
        kwargs = {
            'database': self.database,
            'money_chain_community': chain_community,
            'tx_fee': self.options['txfee']
        }
        self.money_community = self.dispersy.define_auto_load(MoneyCommunity, master_member, load=True, kargs=kwargs)[0]
        self.money_community.bank_managers = self.managers

    def enable_switch(self):
        self.is_switch = True

        # Start Dispersy. First, fix the bootstrap server pointer
        os.environ[BOOTSTRAP_FILE_ENVNAME] = 'bootstrap.txt'

        self.dispersy = Dispersy(StandaloneEndpoint(self.options['port'], '0.0.0.0'),
                                 os.path.join(self.cache_dir, u'dispersy'), u'dispersy.db')
        self.dispersy.statistics.enable_debug_statistics(True)
        self.dispersy.start(autoload_discovery=True)

        self.load_money_community()
