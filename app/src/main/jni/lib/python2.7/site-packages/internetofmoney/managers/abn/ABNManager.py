import json

import time
from twisted.internet.defer import succeed

from internetofmoney.managers.abn.ABNBaseManager import ABNBaseManager
from internetofmoney.RequiredField import RequiredField
from internetofmoney.RequiredInput import RequiredInput
from internetofmoney.utils.abnchallenge import ABNChallengeParser
from internetofmoney.utils.abncrypto import ABNCrypto


class ABNManager(ABNBaseManager):
    """
    This class implements the manager used to communicate with the ABN AMRO server.
    """

    def is_logged_in(self):
        return self.logged_in

    def persistent_storage_filename(self):
        return 'abn_account.json'

    def get_address(self):
        return self.persistent_storage['account_iban']

    def get_payment_info_fields(self):
        """
        Return the fields required for making a payment with an ABN AMRO account.
        """
        amount_field = RequiredField('amount', 'text', 'Please enter the amount of money to transfer')
        destination_field = RequiredField('destination_account', 'text', 'Please enter the destination IBAN account')
        description_field = RequiredField('description', 'text', 'Please the payment description')
        return [amount_field, destination_field, description_field]

    def get_registration_fields(self):
        account_field = RequiredField('account', 'text', 'Please enter your ABN account number (without the IBAN part)',
                                      placeholder='Account number')
        card_field = RequiredField('card', 'text', 'Please enter your card number', placeholder='Card number')
        return [account_field, card_field]

    #
    # Registration
    #

    def register(self):
        """
        Register an existing bank account to use the mobile services.
        :return: A deferred that fires when the account has been registered.
        """
        required_input = RequiredInput('abn_account_info', self.get_registration_fields())
        return self.input_handler(required_input).addCallback(self.perform_first_login_challenge_request)

    def perform_first_login_challenge_request(self, input):
        self.persistent_storage['account_number'] = input['account']
        self.persistent_storage['card_number'] = input['card']
        self.save_storage()

        url = "https://www.abnamro.nl/session/loginchallenge?accessToolUsage=EDENTIFIER2_UNCONNECTED&" \
              "accountNumber=0%s&cardNumber=%s&appId=SIMPLE_BANKING" % (input['account'], input['card'])
        return self.perform_request(url,  headers=self.get_abn_headers(service_version='v2')) \
            .addCallback(self.on_first_challenge_request_response).addErrback(self.on_first_challenge_request_error)

    def on_first_challenge_request_response(self, response):
        challenge_json = json.loads(response)
        self.tool_id = challenge_json['loginChallenge']['userId']

        code_field = RequiredField('first_challenge', 'text',
                                   'Please enter the login challenge code from your edentifier')
        required_input = RequiredInput('abn_first_challenge', [code_field])
        return self.input_handler(required_input).addCallback(
            lambda input: self.on_first_challenge_input(input, challenge_json))

    def on_first_challenge_request_error(self, failure):
        required_input = RequiredInput('abn_account_info', self.get_registration_fields(),
                                       error_text='Invalid information entered')
        return self.input_handler(required_input).addCallback(self.perform_first_login_challenge_request)

    def on_first_challenge_input(self, input, challenge_json):
        response_dict = {"accountNumber": int(self.persistent_storage['account_number']),
                         "accessToolUsage": "EDENTIFIER2_UNCONNECTED",
                         "appId": "SIMPLE_BANKING",
                         "response": input['first_challenge'],
                         "challengeHandle": challenge_json["loginChallenge"]["challengeHandle"],
                         "challengeDeviceDetails": "\/schemes\/ATT_1_15\/CH_1",
                         "eigChallengeHandle": None,
                         "eigChallengeDeviceDetails": None,
                         "cardNumber": int(self.persistent_storage['card_number'])}

        return self.perform_request('https://www.abnamro.nl/session/loginresponse', raw_data=json.dumps(response_dict),
                                    request_type='PUT', headers=self.get_abn_headers(is_json=True)) \
            .addCallback(self.on_first_challenge_response)

    def on_first_challenge_response(self, response):
        return self.perform_request('https://www.abnamro.nl/softtokens/session',
                                    headers=self.get_abn_headers(include_service_version=False))\
            .addCallback(self.on_softtoken_session_response)

    def on_softtoken_session_response(self, response):
        return self.perform_request('https://www.abnamro.nl/softtokens/undefined/signingchallenge?userSetDayLimit=50',
                                    headers=self.get_abn_headers(is_json=True, include_service_version=False)) \
            .addCallback(self.on_signing_challenge_response)

    def on_signing_challenge_response(self, response):
        json_response = json.loads(response)
        signing_code = json_response['softTokenSigningChallenge']['challenge']

        input_text = 'Please enter the edentifier response to the code %s' % str(signing_code)
        code_field = RequiredField('scenario_challenge', 'text', input_text, placeholder='Edentifier response')
        required_input = RequiredInput('abn_scenario_challenge', [code_field])
        return self.input_handler(required_input).addCallback(
            lambda input: self.on_user_token_input(input, signing_code))

    def on_user_token_input(self, input, signing_code):
        return self.perform_request('https://www.abnamro.nl/softtokens/softtokenpasswordchallenge?command=4',
                                    headers=self.get_abn_headers(is_json=True, include_service_version=False)) \
            .addCallback(lambda response: self.on_soft_token_challenge_response(response, str(input['scenario_challenge'])))

    def on_soft_token_challenge_response(self, response, challenge_input):
        challenge_json = json.loads(response)

        new_code_field = RequiredField('id_code', 'text', 'Please enter your new 5-digit identification code',
                                       placeholder='New identification code')
        required_input = RequiredInput('abn_registration_id_code', [new_code_field])
        return self.input_handler(required_input).addCallback(
            lambda user_input: self.perform_soft_token_request(user_input, challenge_json, challenge_input))

    def perform_soft_token_request(self, user_input, challenge_json, challenge_input):
        challenge = challenge_json["softTokenPasswordChallenge"]["challenge"]
        challenge_handle = challenge_json["softTokenPasswordChallenge"]["challengeHandle"]

        challenge_dict = ABNChallengeParser.parse_challenge_hex_string(challenge)
        modulus = long(challenge_dict[4].encode('hex'), 16)
        exponent = long(challenge_dict[5].encode('hex'), 16)

        public_key = ABNCrypto.construct_public_rsa_key(modulus, exponent)

        self.persistent_storage['identification_code'] = user_input['id_code']
        self.persistent_storage['registered'] = True
        self.save_storage()

        soft_token_id = challenge_json["softTokenPasswordChallenge"]["softTokenId"]
        data_dict = {1: "4", 2: challenge_dict[2], 3: challenge_dict[3], 8: soft_token_id, 9: user_input['id_code']}
        plain_hex_string = ABNChallengeParser.construct_hex_string_from_dict(data_dict).decode('hex')
        password_response = ABNCrypto.encrypt(plain_hex_string, public_key).encode("hex")

        response_dict = {"userSetDayLimit": 50, "passwordResponse": password_response,
                         "passwordChallengeHandle": challenge_handle, "signingChallengeResponse": challenge_input}
        return self.perform_request('https://www.abnamro.nl/softtokens', request_type='POST',
                                    raw_data=json.dumps(response_dict),
                                    headers=self.get_abn_headers(service_version='v3', is_json=True))\
            .addCallback(self.on_soft_token_done_response)

    def on_soft_token_done_response(self, response):

        # Get the account information and store it if we don't have it - we need this information later on
        def on_accounts(accounts):
            for account in accounts:
                if account['contractNumber'] == self.persistent_storage['account_number']:
                    self.persistent_storage['account_iban'] = account['accountNumber']
                    self.persistent_storage['contract_number'] = account['contractNumber']
                    self.persistent_storage['payer_name'] = account['customer']['interpayName']
                    self.save_storage()
                    break

        return self.get_accounts().addCallback(on_accounts)

    #
    # Login
    #

    def login(self):
        """
        Login to an ABN AMRO account. First, check whether we have an identification code set. If not, ask for it and
        use it to login.
        """
        if 'identification_code' in self.persistent_storage:
            return self.login_with_code(str(self.persistent_storage['identification_code']))
        else:
            id_code_field = RequiredField('id_code', 'text', 'Please enter your ABN identification code',
                                          placeholder='Identification code')
            required_input = RequiredInput('abn_id_code', [id_code_field])
            return self.input_handler(required_input).addCallback(self.on_entered_login_code)

    def on_entered_login_code(self, input):
        return self.login_with_code(input['id_code'])

    def login_with_code(self, login_code):
        """
        Login with an identification code.
        :param login_code: The identification code to use for the login.
        :return: A deferred that fires when the user is logged in.
        """
        account_number = str(self.persistent_storage['account_number'])
        card_number = str(self.persistent_storage['card_number'])
        return self.perform_request('https://www.abnamro.nl/session/loginchallenge?accessToolUsage='
                                    'SOFTTOKEN&accountNumber=%s&cardNumber=%s' % (account_number, card_number),
                                    headers=self.get_abn_headers(is_json=True, include_service_version=False)) \
            .addCallback(lambda response: self.on_login_challenge_response(response, login_code))

    def on_login_challenge_response(self, response, login_code):
        challenge_json = json.loads(response)
        challenge = challenge_json["loginChallenge"]["challenge"]
        challenge_handle = challenge_json["loginChallenge"]["challengeHandle"]
        user_id = challenge_json["loginChallenge"]["userId"]

        challenge_dict = ABNChallengeParser.parse_challenge_hex_string(challenge)
        modulus = long(challenge_dict[4].encode('hex'), 16)
        exponent = long(challenge_dict[5].encode('hex'), 16)

        public_key = ABNCrypto.construct_public_rsa_key(modulus, exponent)
        data_dict = {1: "1", 2: challenge_dict[2], 3: challenge_dict[3], 8: user_id, 9: login_code}
        encrypted_response = ABNCrypto.encrypt(ABNChallengeParser.construct_hex_string_from_dict(data_dict).decode('hex'), public_key).encode("hex")
        response_dict = {"accountNumber": int(self.persistent_storage['account_number']),
                         "accessToolUsage": "SOFTTOKEN",
                         "appId": "SIMPLE_BANKING",
                         "response": encrypted_response,
                         "challengeHandle" : challenge_handle,
                         "challengeDeviceDetails" : "/schemes/ATT_5_55/CH_1",
                         "cardNumber": int(self.persistent_storage['card_number'])}

        return self.perform_request('https://www.abnamro.nl/session/loginresponse',
                                    headers=self.get_abn_headers(is_json=True), request_type='PUT',
                                    raw_data=json.dumps(response_dict)) \
            .addCallback(self.on_login_challenge_submit_response)

    def on_login_challenge_submit_response(self, response):
        json_response = json.loads(response)
        self.customer_number = str(json_response['session']['representedCustomer'])
        self.logged_in = True

    #
    # Get balance
    #

    def get_balance(self):
        """
        Fetch the balance of an ABN AMRO account.
        :return: A deferred that fires with a dictionary containing the balance when successful.
        """
        def perform_balance_request(_):
            request_url = 'https://www.abnamro.nl/contracts?includeActions=BASIC&includeActionNames=' \
                          'VIEW_PORTFOLIO_OVERVIEW,VIEW_PAYMENTS,APM_ADVISE_CONTRACTFILTER,MANAGE_DOMESTIC_PAYMENTS,' \
                          'MANAGE_INTERNATIONAL_PAYMENTS,SIGN_DOMESTIC_PAYMENTS,SIGN_INTERNATIONAL_PAYMENTS,' \
                          'SIGN_STANDING_ORDER,VIEW_PROFILE_FUND_SETTINGS&excludeBlocked=false&' \
                          'productGroups=PAYMENT_ACCOUNTS,SAVINGS_ACCOUNTS,INVESTMENTS,' \
                          'CREDITS_MAHUKO_REVOLVING,FISCAL_CAPITAL_SOLUTIONS_PRODUCTS,MORTGAGE&' \
                          'productBuildingBlocks=5,8,13,25,15'
            return self.perform_request(request_url,
                                        headers=self.get_abn_headers(is_json=True, service_version='v2')) \
                .addCallback(self.on_balance_response)
        return self.check_login().addCallback(perform_balance_request)

    def on_balance_response(self, response):
        json_response = json.loads(response)
        for contract in json_response['contractList']:
            if contract['contract']['accountNumber'].endswith(self.persistent_storage['account_number']):
                return {
                    'available': float(contract['contract']['balance']['amount']),
                    'pending': 0.0,
                    'currency': 'EUR'
                }

    #
    # Get accounts
    #

    def get_accounts(self):
        """
        Get information about your accounts.
        :return: A deferred that fires with information about your accounts.
        """
        request_url = 'https://www.abnamro.nl/contracts?includeActions=BASIC&includeActionNames=' \
                      'VIEW_PORTFOLIO_OVERVIEW,VIEW_PAYMENTS,APM_ADVISE_CONTRACTFILTER,MANAGE_DOMESTIC_PAYMENTS,' \
                      'MANAGE_INTERNATIONAL_PAYMENTS,SIGN_DOMESTIC_PAYMENTS,SIGN_INTERNATIONAL_PAYMENTS,' \
                      'SIGN_STANDING_ORDER,VIEW_PROFILE_FUND_SETTINGS&excludeBlocked=false&' \
                      'productGroups=PAYMENT_ACCOUNTS,SAVINGS_ACCOUNTS,INVESTMENTS,' \
                      'CREDITS_MAHUKO_REVOLVING,FISCAL_CAPITAL_SOLUTIONS_PRODUCTS,MORTGAGE&' \
                      'productBuildingBlocks=5,8,13,25,15'
        return self.perform_request(request_url,
                                    headers=self.get_abn_headers(is_json=True, service_version='v2')) \
            .addCallback(self.on_accounts_response)

    def on_accounts_response(self, response):
        return [account["contract"] for account in json.loads(response)["contractList"]]

    #
    # Get transactions
    #

    def get_transactions(self):
        """
        Fetch the most recent transactions of an ABN AMRO account.
        :return: A deferred that fires with a list containing transactions.
        """
        def perform_transactions_request(_):
            iban = self.persistent_storage['account_iban']
            return self.perform_request('https://www.abnamro.nl/mutations/%s?includeActions=EXTENDED' % str(iban),
                                        headers=self.get_abn_headers()).addCallback(self.on_transactions_response)
        return self.check_login().addCallback(perform_transactions_request)

    def parse_descriptions(self, descriptions):
        return '\n'.join([description.rstrip() for description in descriptions])

    def on_transactions_response(self, response):
        json_response = json.loads(response)
        transactions = []
        for transaction in json_response['mutationsList']['mutations']:
            mutation = transaction['mutation']
            outgoing = mutation['amount'] < 0
            if outgoing:
                from_account = mutation['accountNumber']
                to_account = mutation['counterAccountNumber']
            else:
                from_account = mutation['counterAccountNumber']
                to_account = mutation['accountNumber']

            transaction_dict = {
                "id": str(mutation['transactionTimestamp']),
                "outgoing": outgoing,
                "from": str(from_account),
                "to": str(to_account),
                "amount": abs(mutation['amount']),
                "fee_amount": 0.0,
                "currency": str(mutation['currencyIsoCode']),
                "timestamp": str(mutation['transactionDate']),
                "description": str(self.parse_descriptions(mutation['descriptionLines']))
            }
            transactions.append(transaction_dict)
        return transactions

    #
    #  Perform payment
    #

    def make_payment(self):
        """
        Initiate a new payment by asking the user for payment details.
        """
        required_input = RequiredInput('abn_payment_info', self.get_payment_info_fields())
        return self.input_handler(required_input).addCallback(self.on_entered_payment_details)

    def on_entered_payment_details(self, user_input):
        return self.perform_payment(user_input['amount'], user_input['destination_account'], user_input['description'])

    def perform_payment(self, amount, destination_account, description):
        """
        Perform a payment.
        :param amount: the amount of money to transfer, in euro (i.e. 3.14).
        :param destination_account: the destination of the payment.
        :param description: an optional description that is appended to the payment.
        :return: A deferred that fires with a transaction id when the payment has been successful.
        """
        millis = int(round(time.time() * 1000))
        response_dict = {
            "sepaPaymentInstruction": {
                "paymentInstructionTransactionPart": {
                    "indicationImmediate": True,
                    "remittanceInfoType": "UNSTRUCTURED",
                    "accountNumber": destination_account,
                    "currencyIsoCode": "EUR",
                    "counterParties": [{
                        "name": "receiver", "type": "CREDITOR"
                    }],
                    "amount": float(amount),
                    "remittanceInfo": description,
                    "@resourceType": "SepaPaymentInstructionTransactionPart",
                    "executionDate": millis
                },
                "orderingParties": [{"name": str(self.persistent_storage['payer_name']), "type": "DEBTOR"}],
                "accountNumber": str(self.persistent_storage['account_iban']),
                "businessContactNumber": self.customer_number,
                "buildingBlockId": 5,
                "@resourceType": "SepaCreditTransferPaymentInstruction",
                "contractNumber": str(self.persistent_storage['contract_number'])
            }
        }

        return self.perform_request('https://www.abnamro.nl/paymentinstructions/single/sepa',
                                    raw_data=json.dumps(response_dict),
                                    request_type='POST',
                                    headers=self.get_abn_headers(is_json=True, service_version='v2')) \
            .addCallback(self.on_payment_instructions_response)

    def on_payment_instructions_response(self, response):
        json_response = json.loads(response)
        id1 = json_response["sepaPaymentInstruction"]["id"]["id1"]
        source_id = json_response["sepaPaymentInstruction"]["id"]["sourceId"]

        response_dict = {
            "signingBasket": {
                "signitemIds": [{"signItemId": {"itemId": id1, "sourceId": source_id}}]
            }
        }

        return self.perform_request('https://www.abnamro.nl/session/signingbasket',
                                    raw_data=json.dumps(response_dict),
                                    request_type='PUT',
                                    headers=self.get_abn_headers(is_json=True, include_service_version=False)) \
            .addCallback(self.on_add_signing_basket_response)

    def on_add_signing_basket_response(self, response):
        # Get signing methods
        return self.perform_request('https://www.abnamro.nl/session/signingbasket/signingmethods',
                                    headers=self.get_abn_headers(include_service_version=False)) \
            .addCallback(self.on_signing_methods_response)

    def on_signing_methods_response(self, response):
        # Check whether we need to sign this transaction with our edentifier or not
        json_response = json.loads(response)
        soft_token_available = False
        for signing_method in json_response["signingMethodList"]:
            if signing_method["signingMethod"]["deviceType"] == "SOFTTOKEN":
                soft_token_available = True
                self.tool_id = str(signing_method["signingMethod"]["accessTools"][0]["accessTool"]["toolId"])
                break

        if soft_token_available:
            return self.perform_signing_basket_whitelisted()
        else:
            return self.perform_signing_basket_challenge()

    def perform_signing_basket_whitelisted(self):
        return self.perform_request('https://www.abnamro.nl/session/signingbasket/challenge?deviceType=SOFTTOKEN&connectionType=ENDTOEND&toolId=%s' % self.tool_id,
                                    headers=self.get_abn_headers(service_version='v2')) \
            .addCallback(self.on_signing_basket_challenge_response)

    def on_signing_basket_challenge_response(self, response):
        json_response = json.loads(response)
        challenge = json_response["signingBasketChallenge"]["challenge"]

        # Solve the challenge
        challenge_dict = ABNChallengeParser.parse_challenge_hex_string(challenge)

        modulus = long(challenge_dict[4].encode('hex'), 16)
        exponent = long(challenge_dict[5].encode('hex'), 16)

        public_key = ABNCrypto.construct_public_rsa_key(modulus, exponent)
        data_dict = {1: "2", 2: challenge_dict[2], 3: challenge_dict[3], 6: challenge_dict[6],
                     9: self.persistent_storage['identification_code']}
        response = ABNCrypto.encrypt(ABNChallengeParser.construct_hex_string_from_dict(data_dict).decode('hex'),
                                   public_key).encode("hex")

        response_dict = {"signingBasketResponse": {"response": response, "returncodeConnectedReader": "0"}}
        return self.perform_request('https://www.abnamro.nl/session/signingbasket/response',
                                    raw_data=json.dumps(response_dict),
                                    request_type='PUT',
                                    headers=self.get_abn_headers(is_json=True, include_service_version=False)) \
            .addCallback(self.on_payment_challenge_response)

    def on_payment_challenge_response(self, response):
        json_response = json.loads(response)
        return str(json_response['signingBasket']['signItemList'][0]['signItem']['itemId'])

    def perform_signing_basket_challenge(self):
        # TODO implement this stuff
        pass
